<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>getline()</title>
      <link href="/2019/07/10/getline/"/>
      <url>/2019/07/10/getline/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure><p>delim(分隔符)，表示遇到这个字符停止读入，系统默认该字符为’\n’ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline (<span class="built_in">cin</span>, line, <span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>当输入 24gm is * the best ，时 读入输入流的只有 24gm is， <em>后面的并没有存入line中。<br>注意， 由于此时delim设定为`</em><code>所以即使输入 回车键  也不会停止读入，只有遇到</code>*` 时才会停止读入。</p><h2 id="c-读取以逗号为分隔符的一串数字"><a href="#c-读取以逗号为分隔符的一串数字" class="headerlink" title="c++读取以逗号为分隔符的一串数字"></a>c++读取以逗号为分隔符的一串数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> inter;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (is &gt;&gt; inter)</span><br><span class="line">    &#123;</span><br><span class="line">         v.push_back(inter);</span><br><span class="line">         is &gt;&gt; ch;  <span class="comment">//把数字后面的逗号读取走，这样下次循环时 is中就是从逗号后面的数字开始了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于上述程序注释的说明：</span><br><span class="line">```C++</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="keyword">int</span> inter;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">is &gt;&gt; inter;</span><br><span class="line">is &gt;&gt; ch;</span><br><span class="line">is &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"inter: "</span> &lt;&lt; inter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ch: "</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="//zhhp1001.github.io/2019/07/10/getline/3.png" alt></p><hr><p>输入 24,35,55,85,135<br>输出 24 35 55 85 135</p><p>注意在vs中 进入黑色的命令行界面时 要注意输入法是否是英文， 否则会出现错误。<br>下图这样的输入 逗号后似乎还有空格， 这样程序输出就会错误。<br><img src="//zhhp1001.github.io/2019/07/10/getline/1.png" alt><br>正确输入如下<br><img src="//zhhp1001.github.io/2019/07/10/getline/2.png" alt></p><h3 id="stringstream通常是用来做数据转换的"><a href="#stringstream通常是用来做数据转换的" class="headerlink" title="stringstream通常是用来做数据转换的"></a>stringstream通常是用来做数据转换的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> result=”<span class="number">10000</span>”;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">stream&lt;&lt;result;</span><br><span class="line">stream&gt;&gt;n;<span class="comment">//n等于10000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> getline() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化、反序列化二叉树</title>
      <link href="/2019/07/10/%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/07/10/%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-297-Serialize-and-Deserialize-Binary-Tree"><a href="#LeetCode-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="LeetCode 297. Serialize and Deserialize Binary Tree"></a>LeetCode 297. <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">Serialize and Deserialize Binary Tree</a></h1><h2 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">ostringstream</span>&amp; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;                         <span class="comment">//以前序遍历的顺序序列化二叉树</span></span><br><span class="line">            out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            serialize(root-&gt;left, out);</span><br><span class="line">            serialize(root-&gt;right, out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        root-&gt;left = deserialize(in);</span><br><span class="line">        root-&gt;right = deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="deserialize-实现二"><a href="#deserialize-实现二" class="headerlink" title="deserialize 实现二"></a>deserialize 实现二</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n;</span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      in &gt;&gt; n;   <span class="comment">//从前序遍历顺序的 序列化二叉树中读取一个字符，转化为int。（&gt;&gt;运算符遇空白符e.g.空格、制表符、换行中止）</span></span><br><span class="line">      <span class="keyword">if</span>(in.fail()) &#123;   <span class="comment">//当读取失败时，in的fail() 返回 true。 (注1)</span></span><br><span class="line"></span><br><span class="line">          in.clear();   <span class="comment">// 调用流对象的clear()， 复位流的所有条件状态。</span></span><br><span class="line">          in &gt;&gt; ch;    <span class="comment">// 用一个char字符读取流中的下一位字符（即#）。</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">          </span><br><span class="line">      </span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">      root-&gt;left = deserialize(in);</span><br><span class="line">      root-&gt;right = deserialize(in);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注1： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; val;</span><br></pre></td></tr></table></figure><p>如果我们输入Boo, 上面的读操作就会失败。代码中的输入运算符期待读取一个int, 但却得到了一个字符B。这样，cin 会进入错误状态（类似的，如果输入一个eof，cin也会进入错误状态）。一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。<br>确定一个流对象的状态的最简单的方法是将它当作一个条件来使用 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) <span class="comment">// while 循环检查 &gt;&gt; 表达式返回的流的状态。如果输入操作成功，流保持有效状态， 则条件为真</span></span><br></pre></td></tr></table></figure><h2 id="上述deserialize代码还可改为："><a href="#上述deserialize代码还可改为：" class="headerlink" title="上述deserialize代码还可改为："></a>上述deserialize代码还可改为：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="keyword">char</span> ch;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">if</span>(!(in &gt;&gt; n)) &#123;   </span><br><span class="line">         in.clear();  </span><br><span class="line">         in &gt;&gt; ch;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     &#125;</span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">     TreeNode* root = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">     root-&gt;left = deserialize(in);</span><br><span class="line">     root-&gt;right = deserialize(in);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总之就是记住 流一旦发生错误，其后续IO操作都会失败，所以下次IO操作前要先用clear()清空（或者叫复位）条件状态标志位。</p><h2 id="stoi"><a href="#stoi" class="headerlink" title="stoi()"></a>stoi()</h2><p>将string 转化为int  所谓stoi 是不是 string to int …<br>虽然在上面哪个题里 stringstream  也可以进行数据类型转换， 但是 从输入流里往 int类型对象里读入（存入）数据 遇到 # 就会中断。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化、反序列化二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把二叉树打印成多行</title>
      <link href="/2019/07/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
      <url>/2019/07/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"><a href="#从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。" class="headerlink" title="从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"></a>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = que.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode* node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            level.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                que.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">            res.push_back(level);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> res;           </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里只用一个队列就可以了， 注意进入while循环时， 先计算队列的大小， 然后用for循环处理完这层的所有元素后再转到下一层的元素。</p><h1 id="清空vector中的所有元素"><a href="#清空vector中的所有元素" class="headerlink" title="清空vector中的所有元素"></a>清空vector中的所有元素</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 把二叉树打印成多行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-113-Path-Sum-II"><a href="#LeetCode-113-Path-Sum-II" class="headerlink" title="LeetCode 113. Path Sum II"></a>LeetCode 113. <a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">Path Sum II</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; paths;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        DFS (root, sum, path, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;val == sum) &#123;</span><br><span class="line">            paths.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS (root-&gt;left, sum - root-&gt;val, path, paths);</span><br><span class="line">        DFS (root-&gt;right, sum - root-&gt;val, path, paths);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DFS 函数 返回值设为 void</li><li>path.pop_back()</li></ul><p>删除vector 容器末尾元素 </p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度</title>
      <link href="/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-104-Maximum-Depth-of-Binary-Tree"><a href="#LeetCode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode 104. Maximum Depth of Binary Tree"></a>LeetCode 104. <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a></h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftTree = maxDepth (root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightTree = maxDepth (root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max (leftTree, rightTree) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当前节点的最大深度 = 左右子树最大深度的较大者 + 1</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; level;</span><br><span class="line">    level.push(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!level.empty()) &#123;</span><br><span class="line">        depth++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = level.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode* node = level.front();</span><br><span class="line">            level.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                level.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                level.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代时间8ms 明显 优于 递归的24ms<br><img src="//zhhp1001.github.io/2019/07/09/二叉树的最大深度/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的最大深度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一棵树是否为另一棵树的子结构</title>
      <link href="/2019/07/09/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/07/09/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-572-Subtree-of-Another-Tree"><a href="#LeetCode-572-Subtree-of-Another-Tree" class="headerlink" title="LeetCode 572. Subtree of Another Tree"></a>LeetCode 572. <a href="https://leetcode.com/problems/subtree-of-another-tree/submissions/" target="_blank" rel="noopener">Subtree of Another Tree</a></h1><h2 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSame(s, t)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSubtree (s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span> <span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s &amp;&amp; !t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s || !t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;val != t-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSame (s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题让我们求一个数是否是另一个树的子树，从题目中的第二个例子中可以看出，子树必须是从叶结点开始的，中间某个部分的不能算是子树，那么我们转换一下思路，是不是从s的某个结点开始，跟t的所有结构都一样，那么问题就转换成了判断两棵树是否相同，也就是Same Tree的问题了，这点想通了其实代码就很好写了，用递归来写十分的简洁，我们先从s的根结点开始，跟t比较，如果两棵树完全相同，那么返回true，否则就分别对s的左子结点和右子结点调用递归再次来判断是否相同，只要有一个返回true了，就表示可以找得到。</p><h2 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h2><p>The question is exactly similar to the Leetcode 100 Same Tree<br>Solution for Leetcode 100: <a href="https://leetcode.com/problems/same-tree/discuss/148340/CPP-Easy-to-Understand" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/discuss/148340/CPP-Easy-to-Understand</a></p><p>Also Check Leetcode 101 [Symmetric Tree]<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/description/</a>)Leetcode 101 eh? :P</p><p>Okay so now you will be absolutely comfortable with this question. It just requires you to</p><p>1.Start with a node of tree s (lets call this s-node)<br>2.Compare the trees forming with root s-node and root t<br>3.If the trees match(leetcode 100 logic) then return true<br>4.Else go to step one and check for s-&gt;left || s-&gt;right</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(s,t) || isSubtree(s-&gt;left,t) || isSubtree(s-&gt;right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Leetcode 100</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span> || q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val == q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-101-Symmetric-Tree"><a href="#LeetCode-101-Symmetric-Tree" class="headerlink" title="LeetCode 101. Symmetric Tree"></a>LeetCode 101. <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">Symmetric Tree</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> helper (root-&gt;left, root-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">helper</span> <span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;   <span class="comment">//两边同时为空，说明同时到头了，能走到这一步说明那些return false的不对称条件都没满足（也就是说到这为止这棵树是对称的）。</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) &#123;  <span class="comment">//有一个是空的（那就两边不对称了）</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left-&gt;val == right-&gt;val) &#123;  <span class="comment">//对称位置数值相等， 更新参数，继续前进。</span></span><br><span class="line">           <span class="keyword">return</span> helper (left-&gt;left, right-&gt;right) &amp;&amp; helper (left-&gt;right, right-&gt;left);</span><br><span class="line">       &#125; <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">               </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的子结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/2019/07/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/07/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-105-重建二叉树from-VLR-amp-amp-LVR"><a href="#LeetCode-105-重建二叉树from-VLR-amp-amp-LVR" class="headerlink" title="LeetCode 105. 重建二叉树from VLR &amp;&amp; LVR"></a>LeetCode 105. <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34562/Sharing-my-straightforward-recursive-solution" target="_blank" rel="noopener">重建二叉树from VLR &amp;&amp; LVR</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create (preorder, inorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">create</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = is; i &lt;= ie; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == node-&gt;val) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = create (preorder, inorder, ps + <span class="number">1</span>, ps + pos - is, is, pos - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = create (preorder, inorder, pe - ie + pos + <span class="number">1</span>, pe, pos + <span class="number">1</span>, ie);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let me explain the coordinates in the recursion. Very simply, we can see that the inorder traversal is divided into two parts, [is, pos-1] and [pos+1, ie] according to the root node pointed by pos.The first part contains pos - is elements, and the second part has ie- (pos +1)+1 = ie - pos elements.<br>Correspondingly, in preorder traversal, the elements in the [ps+1, ps+pos - is] intervals belong to the left subtree, and the elements in the [pe - (ie - pos)+1, pe] interval belong to the right subtree.</p><h1 id="LeetCode-106-重建二叉树from-LVR-amp-amp-LRV"><a href="#LeetCode-106-重建二叉树from-LVR-amp-amp-LRV" class="headerlink" title="LeetCode 106 重建二叉树from LVR &amp;&amp; LRV"></a>LeetCode 106 <a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">重建二叉树from LVR &amp;&amp; LRV</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> create (inorder, postorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">create</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(postorder[pe]);</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = is; i &lt;= ie; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == node-&gt;val) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = create (inorder, postorder, is, pos - <span class="number">1</span>, ps, ps + pos - is - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = create (inorder, postorder, pos + <span class="number">1</span>, ie, pe - ie + pos, pe - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重建二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Traits</title>
      <link href="/2019/07/04/Traits/"/>
      <url>/2019/07/04/Traits/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq100440110/article/details/51854673" target="_blank" rel="noopener">Tratis</a></p>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Traits </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题计划</title>
      <link href="/2019/07/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/"/>
      <url>/2019/07/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>理想状态：<br>字符串（8题）    7.1<br>数组 （11题）    7.2<br>链表（8题）      7.3<br>二叉树 （12题）  7.4</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">string</a></h2><p><img src="//zhhp1001.github.io/2019/07/01/剑指offer刷题计划/1.png" alt></p><p>string 与 char</p><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">左旋转字符串</a></h2><p>注意这个if条件，不要漏掉<br><img src="//zhhp1001.github.io/2019/07/01/剑指offer刷题计划/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92" alt></p><h2 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">翻转单词顺序列</a></h2><p><code>str += &#39; &#39;</code>， 在字符串末尾添加一个空格字符。  注意到此处str长度 +1 了， 所以后面用到的str.size() 也已经+1了， 这一点很容易注意不到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        str += <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                reverse (str, j, i - <span class="number">1</span>);</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        str = str.substr(<span class="number">0</span>, str.size() - <span class="number">1</span>);</span><br><span class="line">        reverse (str, <span class="number">0</span>, str.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            swap (str[begin], str[end]);</span><br><span class="line">            begin++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把字符转换成整数"><a href="#把字符转换成整数" class="headerlink" title="把字符转换成整数"></a><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">把字符转换成整数</a></h2><p>这道题注意 这个步骤  <code>res = res * 10 + str[i] - &#39;0&#39;</code> 这里 <code>- &#39;0&#39;</code>的作用是什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> signal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            signal = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (str[<span class="number">0</span>] == <span class="string">'-'</span> || str[<span class="number">0</span>] == <span class="string">'+'</span>) ? <span class="number">1</span> : <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * signal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">快慢指针</a></h1><p>不能对一个nullptr进行操作。</p><p><img src="//zhhp1001.github.io/2019/07/01/剑指offer刷题计划/3.png" alt></p><p>pSlow 指向下一个位置后，要判断一下这个新位置是否为空，如果非空，pFast才能指向新位置的下一个位置。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>permutation &amp; combination</title>
      <link href="/2019/06/27/permutation-combination/"/>
      <url>/2019/06/27/permutation-combination/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-next-permutation"><a href="#LeetCode-next-permutation" class="headerlink" title="LeetCode next permutation"></a>LeetCode <a href="https://leetcode.com/problems/next-permutation/discuss/13867/C%2B%2B-from-Wikipedia" target="_blank" rel="noopener">next permutation</a></h1><p>这道题的讨论区解答很详细， 特别注意一下 <code>reverse(nums.begin(), nums.end())</code> 参数是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">for</span> (k = n - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            reverse (nums.begin(), nums.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (l = n - <span class="number">1</span>; l &gt; k; l--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[k] &lt; nums[l]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap (nums[k], nums[l]);</span><br><span class="line">            reverse (nums.begin() + k + <span class="number">1</span>, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-Permutation"><a href="#LeetCode-Permutation" class="headerlink" title="LeetCode Permutation"></a>LeetCode <a href="https://leetcode.com/problems/permutations/discuss/18360/C%2B%2B-backtracking-and-nextPermutation" target="_blank" rel="noopener">Permutation</a></h1><h2 id="使用-vector-amp-与-第二次swap"><a href="#使用-vector-amp-与-第二次swap" class="headerlink" title="使用 vector&amp; 与 第二次swap"></a>使用 vector<int>&amp; 与 第二次swap</int></h2><p>整个过程只存在一个nums,改变一个nums的操作，就相当于整个流程中的nums都做了相同的变化，因此需要在DFS后再进行一次交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;res;</span><br><span class="line">        DFS(res, nums, 0);</span><br><span class="line">        return res;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums, int pos)&#123;</span><br><span class="line">        if(pos == nums.size())&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">            DFS(res, nums, pos + 1);</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-传值-并去掉第二次的交换"><a href="#使用-传值-并去掉第二次的交换" class="headerlink" title="使用 传值 并去掉第二次的交换"></a>使用 传值 并去掉第二次的交换</h2><p>每次调用DFS都会copy一个nums，因此不用担心调用DFS会对之前的nums有影响，也就不用在调用完递归函数后再进行交换了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        DFS(res, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">            DFS(res, nums, pos + <span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> permutation &amp; combination </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/2019/06/27/static/"/>
      <url>/2019/06/27/static/</url>
      
        <content type="html"><![CDATA[<ul><li><p>加了<code>static</code>关键字的全局变量只能在本文件中使用。</p></li><li><p>static 定义的静态局部变量分配在数据段上。普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。</p></li><li><p>对一个类中成员变量和成员函数来说， 加了static关键字， 则此变量/函数就没有了this指针， 必须通过类名才能访问。</p></li></ul><p>C++.pdf </p><ol start="34"><li></li><li>C++调用C函数需要extern C, 因为C语言没有函数重载.</li><li><code>new</code> 和 <code>delete</code> 是 C++的关键字， 而 <code>malloc</code> 和 <code>free</code> 是 C语言的库函数， 后者使用必须指明申请内存空间的大小， 对于类类型的对象， 后者不会调用构造函数和析构函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2019/06/26/%E9%80%92%E5%BD%92/"/>
      <url>/2019/06/26/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<ul><li>递归、回溯、DFS</li><li>循环是一种特殊的递归，可以称为不需要栈的递归，或者尾递归。<h1 id="好文"><a href="#好文" class="headerlink" title="好文"></a><a href="https://blog.csdn.net/SpeedMe/article/details/21654357#commentBox" target="_blank" rel="noopener">好文</a></h1></li></ul><h2 id="例子-给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了-d格式码，它就会执行类似处理。"><a href="#例子-给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了-d格式码，它就会执行类似处理。" class="headerlink" title="例子 给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了%d格式码，它就会执行类似处理。"></a>例子 给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了%d格式码，它就会执行类似处理。</h2><p>分析：首先我们会想到用4267取余，然后除以10再区域，如此循环。但这样输出的顺序不会是7,6,2,4吗？于是我们就利用递归的堆栈结构的特性：先进后出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">recursion(<span class="number">4267</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> quotient ;</span><br><span class="line">quotient = value/<span class="number">10</span> ;</span><br><span class="line"><span class="keyword">if</span>(quotient!=<span class="number">0</span>)&#123; recursion(quotient) ;&#125;</span><br><span class="line">System.out.println(value%<span class="number">10</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归是如何帮助我们以正确的顺序打印这些字符呢？下面是这个函数的工作流程。</p><ol><li>将参数值除以10</li><li>如果quotient的值为非零，调用binary-to-ascii打印quotient当前值的各位数字</li><li>接着，打印步骤1中除法运算的余数</li></ol><p>注意在第2个步骤中，我们需要打印的是quotient当前值的各位数字。我们所面临的问题和最初的问题完全相同，只是变量quotient的 值变小了。我们用刚刚编写的函数（把整数转换为各个数字字符并打印出来）来解决这个问题。由于quotient的值越来越小，所以递归最终会终止。<br>　　一旦你理解了递归，阅读递归函数最容易的方法不是纠缠于它的执行过程，而是<strong>相信</strong>递归函数会顺利完成它的任务。如果你的每个步骤正确无误，你的限制条件设置正确，并且每次调用之后更接近限制条件，递归函数总是能正确的完成任务。<br>　　但是，为了理解递归的工作原理，你需要追踪递归调用的执行过程，所以让我们来进行这项工作。追踪一个递归函数的执行过程的关键是理解函数中所声明的变量是如何存储的。当函数被调用时，它的变量的空间是创建于运行时堆栈上的。以前调用的函数的变量扔保留在堆栈上，但他们被新函数的变量所掩盖，因此是不能被访问的。<br>　　当递归函数调用自身时，情况于是如此。每进行一次新的调用，都将创建一批变量，他们将掩盖递归函数前一次调用所创建的变量。当我追踪一个递归函数的执行过程时，必须把分数不同次调用的变量区分开来，以避免混淆。<br>　　程序中的函数有两个变量：参数value和局部变量quotient。下面的一些图显示了堆栈的状态，当前可以访问的变量位于栈顶。所有其他调用的变量饰以灰色的阴影，表示他们不能被当前正在执行的函数访问。<br>假定我们以4267这个值调用递归函数。当函数刚开始执行时，堆栈的内容如下图所示：<br><img src="//zhhp1001.github.io/2019/06/26/递归/1.jpg" alt></p><p>执行除法之后，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/2.jpg" alt></p><p>接着，if语句判断出quotient的值非零，所以对该函数执行递归调用。当这个函数第二次被调用之初，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/3.jpg" alt></p><p>堆栈上创建了一批新的变量，隐藏了前面的那批变量，除非当前这次递归调用返回，否则他们是不能被访问的。再次执行除法运算之后，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/4.jpg" alt></p><p>quotient的值现在为42，仍然非零，所以需要继续执行递归调用，并再创建一批变量。在执行完这次调用的出发运算之后，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/5.jpg" alt></p><p>此时，quotient的值还是非零，仍然需要执行递归调用。在执行除法运算之后，堆栈的内容如下:<br><img src="//zhhp1001.github.io/2019/06/26/递归/6.jpg" alt></p><p>不算递归调用语句本身，到目前为止所执行的语句只是除法运算以及对quotient的值进行测试。由于递归调用这些语句重复执行，所以它的效果 类似循环：当quotient的值非零时，把它的值作为初始值重新开始循环。但是，递归调用将会保存一些信息（这点与循环不同），也就好是保存在堆栈中的 变量值。这些信息很快就会变得非常重要。<br>　　现在quotient的值变成了零，递归函数便不再调用自身，而是开始打印输出。然后函数返回，并开始销毁堆栈上的变量值。<br>每次调用putchar得到变量value的最后一个数字，方法是对value进行模10取余运算，其结果是一个0到9之间的整数。把它与字符常量‘0’相加，其结果便是对应于这个数字的ASCII字符，然后把这个字符打印出来。<br><img src="//zhhp1001.github.io/2019/06/26/递归/7.jpg" alt></p><p>接着函数返回，它的变量从堆栈中销毁。接着，递归函数的前一次调用重新继续执行，她所使用的是自己的变量，他们现在位于堆栈的顶部。因为它的value值是42，所以调用putchar后打印出来的数字是2。输出42：<br><img src="//zhhp1001.github.io/2019/06/26/递归/8.jpg" alt></p><p>接着递归函数的这次调用也返回，它的变量也被销毁，此时位于堆栈顶部的是递归函数再前一次调用的变量。递归调用从这个位置继续执行，这次打印的数字是6。在这次调用返回之前，堆栈的内容如下,输出426：<br><img src="//zhhp1001.github.io/2019/06/26/递归/9.jpg" alt></p><p>现在我们已经展开了整个递归过程，并回到该函数最初的调用。这次调用打印出数字7，也就是它的value参数除10的余数。输出4267：<br><img src="//zhhp1001.github.io/2019/06/26/递归/10.jpg" alt></p><h2 id="递归的基本原理："><a href="#递归的基本原理：" class="headerlink" title="递归的基本原理："></a>递归的基本原理：</h2><p>　　１　每一次函数调用都会有一次返回．当程序流执行到某一级递归的结尾处时，它会转移到前一级递归继续执行．</p><p>　　２　递归函数中，位于递归调用前的语句和各级被调函数具有相同的顺序．</p><p>　　３　每一级的函数调用都有自己的局部变量．</p><p>　　４　递归函数中，<strong>位于递归调用语句后的语句的执行顺序和各个被调用函数的顺序相反</strong>．</p><pre><code>    　　 即位于递归函数入口前的语句，由外往里执行；位于递归函数入口后面的语句，由里往外执行。</code></pre><p>　　５　虽然每一级递归有自己的变量，但是函数代码并不会得到复制．</p><p>　　６　递归函数中必须包含可以终止递归调用的语句．</p><h2 id="递归算法一般用于解决三类问题："><a href="#递归算法一般用于解决三类问题：" class="headerlink" title="递归算法一般用于解决三类问题："></a>递归算法一般用于解决三类问题：</h2><p>　　(1)数据的定义是按递归定义的。(Fibonacci函数)</p><p>　　(2)问题解法按递归算法实现。(回溯)</p><p>　　(3)数据的结构形式是按递归定义的。(树的遍历，图的搜索)</p><h1 id="To-Iterate-Human-to-Recurse-Divine"><a href="#To-Iterate-Human-to-Recurse-Divine" class="headerlink" title="To Iterate,Human; to Recurse, Divine"></a>To Iterate,Human; to Recurse, Divine</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B&gt;"</span>;</span><br><span class="line"><span class="keyword">for</span> (i; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I&gt;"</span>;</span><br><span class="line">recur(i + <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"R&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution solve;</span><br><span class="line">solve.recur(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我改变recur中 n 的值， 来看看输出的变化：</p><p><img src="//zhhp1001.github.io/2019/06/26/递归/1.png" alt="n = 1"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/2.png" alt="n = 2"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/3.png" alt="n = 3"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/4.png" alt="n = 4"><br>在for循环中添加变量j </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I&gt;"</span>;</span><br><span class="line">recur(i + <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"R&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//zhhp1001.github.io/2019/06/26/递归/5.png" alt="n = 2"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/6.png" alt="n = 3"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/7.png" alt="n = 4"></p><p>太疯狂了！ for 循环 加一个变量， 或者增加一层循环， 程序的执行次数就大大增加…所以，阅读递归函数最容易的方法不是纠缠于它的执行过程，而是<strong>相信</strong>递归函数会顺利完成它的任务。</p><h1 id="Leetcode-Swap-Nodes-in-Pairs"><a href="#Leetcode-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode Swap Nodes in Pairs"></a>Leetcode <a href="https://leetcode.com/explore/learn/card/recursion-i/250/principle-of-recursion/1681/discuss/11271/Simple-implementation-with-C++" target="_blank" rel="noopener">Swap Nodes in Pairs</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs (tmp-&gt;next);</span><br><span class="line">        tmp-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-Pascal’s-Triangle"><a href="#LeetCode-Pascal’s-Triangle" class="headerlink" title="LeetCode Pascal’s Triangle"></a>LeetCode <a href="https://leetcode.com/explore/learn/card/recursion-i/251/scenario-i-recurrence-relation/1659" target="_blank" rel="noopener">Pascal’s Triangle</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(numRows);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            res[i].resize(i + <span class="number">1</span>);</span><br><span class="line">            res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意因为后面有对res 元素的操作， 所以开头定义 vector&lt;vector<int>&gt; 时 要注意初始化。<br>假设numRows = 5， 那么我们需要首先将<code>vector&lt;vector&lt;int&gt;&gt;</code>初始化为<br>[<br>[]<br>[]<br>[]<br>[]<br>[]<br>]否则后面的res[i][j]等操作就是在null上的无意义操作了（似乎可以看一下stl源码剖析，进一步理解vector的迭代器）。</int></li><li>resize()</li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生日过后</title>
      <link href="/2019/06/26/%E7%94%9F%E6%97%A5%E8%BF%87%E5%90%8E/"/>
      <url>/2019/06/26/%E7%94%9F%E6%97%A5%E8%BF%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<p>感觉一直是找不到确切的方向，以至一直坚持不下来，软件、算法，找工作到底想要什么还是不确定。专利和大论文也是没有什么想法。一点点做吧。6.26，赶在这个六月结束前搞好专利吧先。</p>]]></content>
      
      
      <categories>
          
          <category> 记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法</title>
      <link href="/2019/06/25/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2019/06/25/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer矩阵中的路径"><a href="#剑指offer矩阵中的路径" class="headerlink" title="剑指offer矩阵中的路径"></a>剑指offer<a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">矩阵中的路径</a></h1>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印矩阵</title>
      <link href="/2019/06/25/%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/06/25/%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer-顺时针打印矩阵"><a href="#剑指offer-顺时针打印矩阵" class="headerlink" title="剑指offer 顺时针打印矩阵"></a>剑指offer <a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">顺时针打印矩阵</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix ) &#123;</span><br><span class="line">            <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">            <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span> (rows == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">                <span class="comment">//从左到右</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) &#123;</span><br><span class="line">                    result.push_back(matrix[top][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从上到下</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                    result.push_back(matrix[i][right]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从右到左</span></span><br><span class="line">                <span class="keyword">if</span> (top != bottom) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                        result.push_back(matrix[bottom][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从下到上</span></span><br><span class="line">                <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                        result.push_back(matrix[i][left]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++, right--, top++, bottom--;  <span class="comment">//更新控制量</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从右向左和从下到上 要 分别考虑 单行 、 单列 两种特殊情况。 一圈结束后（→，↓，←，↑）记得更新控制量 i.e. 一圈的四个边界。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旋转打印矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort</title>
      <link href="/2019/06/23/sort/"/>
      <url>/2019/06/23/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p><img src="//zhhp1001.github.io/2019/06/23/sort/insert.gif" alt><br>每次把一个新数据插入到有序队列中的合适位置里。</p><p>假设有一组无序序列 R<sub>0</sub>, R<sub>1</sub>, … , R<sub>N-1</sub>。</p><p>(1) 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。</p><p>(2) 然后，我们要依次把  R<sub>0</sub>, R<sub>1</sub>, … , R<sub>N-1</sub> 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。</p><p>(3) 接下来描述插入过程。假设这是要将 R<sub>i</sub> 插入到前面有序的序列中。由前面所述，我们可知，插入 R<sub>i</sub>时，前 i-1 个数肯定已经是有序了。</p><p>所以我们需要将 R<sub>i</sub> 和R<sub>0</sub> ~  R<sub>i-1</sub> 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insertionSort(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (input.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = result[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--) &#123;</span><br><span class="line">result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : iv) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve = insertionSort(iv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solve.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>每趟从待排序的序列中选出最小的元素，顺序放在已排序的序列末尾。</p><ul><li>从待排序序列中，找到关键字最小的元素；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。<br><img src="//zhhp1001.github.io/2019/06/23/sort/select.gif" alt></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selectSort(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (input.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; result.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[index] &gt; result[j]) &#123;</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == i) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(result[index], result[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"次循环:  "</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : result) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前 ："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : iv) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve = selectSort(iv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>快速排序的精髓在于partition()，我们把第一个元素作为pivot的培养对象，经过一次partition()后，数组分为两部分，第一部分<code>&lt;=</code>pivot,第二部分<code>&gt;=</code>pivot。<br>快速排序算法需要两个指针 i、j 分别指向数组的两端， i之前的元素 <code>&lt;=</code>pivot, j之后的元素 <code>&gt;=</code>pivot。两个指针向中间移动，直到遇到一个不符合条件的元素才停止移动。当两个指针都停下时，交换i 、 j 指针指向的元素。<br>重复这个过程。</p><p><img src="//zhhp1001.github.io/2019/06/23/sort/quick.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt;= pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &gt;= pivot) j--;</span><br><span class="line">    swap(a[i], a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了循环就自然要考虑循环的终止条件。可以发现，当i、j两个指针穷尽了各自的区间时循环应该停止， 此时两指针处于 <strong>交错状态</strong>，i指向 <code>&gt;=</code>区域的第一个元素， j指向<code>&lt;=</code>区域的最后一个元素。<br><img src="//zhhp1001.github.io/2019/06/23/sort/sort2.png" alt><br>此时不应该再进行交换操作了。 这时，我们把pivot移动到j处，并且return j这位置， 这样，一次partition操作就完成了。<br>关于i、j两个指针的while循环有数组越界的危险， 假设所有元素都&lt;=pivot， 那么i会越界；假设所有元素都&gt;=pivot，那么j会越界。因此要加上<code>i&lt;=j</code>这个判断来避免越界（注意要有<code>=</code>， 保证i、j会交错）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = first;</span><br><span class="line">    <span class="keyword">int</span> j = last;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[first];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=j &amp;&amp; a[i] &gt;= pivot) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        swap (a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap (a[first],a[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是完整的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = first;</span><br><span class="line"><span class="keyword">int</span> j = last;</span><br><span class="line"><span class="keyword">int</span> p = first;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; vec[i] &lt;= vec[p]) i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; vec[j] &gt;= vec[p]) j--;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">swap(vec[i], vec[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">swap(vec[p], vec[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (last &gt; first) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot = partition(vec, first, last);</span><br><span class="line">quickSort (vec, first, pivot - <span class="number">1</span>);</span><br><span class="line">quickSort (vec, pivot + <span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前： "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : input) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后： "</span>;</span><br><span class="line">quickSort(input, <span class="number">0</span>, input.size() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : input) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><h1 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h1>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影调</title>
      <link href="/2019/06/18/%E5%BD%B1%E8%B0%83/"/>
      <url>/2019/06/18/%E5%BD%B1%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<p>黑白明暗层次变化是影像的骨架和节奏，而色彩则是附着其上的血肉和韵律。亚当斯把0<del>255这个颜色范围分成了0</del>X十一个区，其中0和X分别是纯黑纯白，</p><ul><li>从全黑到全白的0区~X区是<em>全影调幅度</em>；</li><li>I区~IX区是具有基本影调值的<em>有效幅度</em>；</li><li>II~VIII是能够清晰地表现出影调纹理质感的<em>纹理幅度</em>。<img src="//zhhp1001.github.io/2019/06/18/影调/%E4%BA%9A%E5%BD%93%E6%96%AF.png" alt></li></ul><h1 id="影调的划分"><a href="#影调的划分" class="headerlink" title="影调的划分"></a>影调的划分</h1><h2 id="根据画面明暗基调关系划分影调"><a href="#根据画面明暗基调关系划分影调" class="headerlink" title="根据画面明暗基调关系划分影调"></a>根据画面明暗基调关系划分影调</h2><p>对于影调，我们首先可以根据画面中的明暗基调关系（黑白关系）进行划分。在灰阶的11个区域中，0代表纯黑，10代表纯白，我们可以把11级分为低明度、中明度、高明度3个级别。<br><img src="//zhhp1001.github.io/2019/06/18/影调/%E6%98%8E%E6%9A%97.png" alt></p><ul><li>低调（暗调），给人神秘、含蓄、肃穆、庄重、粗豪、倔强和力量的视觉感受。低调形成的基础为黑色，但照片并不是黑成一篇，必须在相应的位置辅以亮色（高光），正因为有大片的暗色调烘托陪衬，小面积的亮色就会显得突出而成为整个画面的视觉中心。</li><li>中调（灰调），有平和与疏淡的感觉。</li><li>高调（亮调），视觉感受为轻盈、纯洁、明快、清秀、宁静、淡雅与舒适。高调照片在浅而苏雅的影调环境中，局部少量的暗色也是必不可少的，这些黑暗影调所构成的部分往往成为画面的视觉中心。<h2 id="根据画面明度对比强弱划分影调"><a href="#根据画面明度对比强弱划分影调" class="headerlink" title="根据画面明度对比强弱划分影调"></a>根据画面明度对比强弱划分影调</h2>在一张照片中，如果明暗灰阶相差5级以上，称为<strong>长调</strong>，画面对比很强烈。相差3~5级以内，称为短调，画面对比很弱，整体层次比较平淡。</li></ul><p>P240</p>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从对象切割说起</title>
      <link href="/2019/06/18/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2%E8%AF%B4%E8%B5%B7/"/>
      <url>/2019/06/18/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临时对象</title>
      <link href="/2019/06/18/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/06/18/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>临时对象（由编译器定义的一个没有命名的非堆（non-heap）对象），不出现在C++代码中，但是确实存在。这种未命名对象有两种产生条件：</p><ul><li>为了使函数调用成功而进行的隐式类型转换。</li><li>函数返回对象。</li></ul><h1 id="C-中对临时变量的引用必须是-const引用。"><a href="#C-中对临时变量的引用必须是-const引用。" class="headerlink" title="C++ 中对临时变量的引用必须是 const引用。"></a>C++ 中对临时变量的引用必须是 const引用。</h1><p>如果一个参数是以一个非const 引用 传入的，那么C++编译器就有理由相信我们传入的参数在函数中是可以被修改的，并且这个修改的变量在函数外也是可以使用的；如果我们把一个<strong>临时对象</strong>当作非const引用参数传进来，则由于对临时变量的修改在函数内部，临时变量在使用完成后就被释放，所以我们修改一个临时变量实际上是<strong>没有意义</strong>的，因此，C++编译器就加入了临时变量不能作为非const引用的这个语义限制。<br>在编译器告诉你错误比在运行期时遇到问题更为友好。</p>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack object / heap object</title>
      <link href="/2019/06/17/stack-object-heap-object/"/>
      <url>/2019/06/17/stack-object-heap-object/</url>
      
        <content type="html"><![CDATA[<h1 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h1><h1 id="栈对象"><a href="#栈对象" class="headerlink" title="栈对象"></a>栈对象</h1><pre><code>由编译器自动分配和释放， 用于保存一些局部变量、函数的参数等。</code></pre><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><p>栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要我们来费心；而且，栈对象的创建速度比堆对象快，因为分配堆对象时会调用 operator new操作， operator new 会采用某种内存空间搜索算法， 而该搜索过程可能很费时间， 栈对象的产生则仅仅需要移动栈顶指针。 但要注意， 栈空间容量较小（1~2M），所以体积较大的对象不适合在栈中分配，特别要注意递归函数最好不要使用栈对象，因为随着递归深度的增加，所需栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，产生运行时错误。</p></li><li><p>因此，当你明确要使用的类型数量时， 使用 Object objec;<br>当你不知道你要创建的类型有多少个时， 使用 Object* object = new Object();</p></li><li><p>栈对象相当于局部对象，堆对象相当于一种能共享于各函数或语句块的对象。栈对象在语句块执行完就自动销毁，堆对象需要手动销毁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专利</title>
      <link href="/2019/06/17/%E4%B8%93%E5%88%A9/"/>
      <url>/2019/06/17/%E4%B8%93%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="实用新型专利"><a href="#实用新型专利" class="headerlink" title="实用新型专利"></a>实用新型专利</h1><p>只要有一些技术改进就可以申请实用新型专利，要注意的是，只有设计产品构造、形状或其结合时，才可申请实用新型专利。实用新型专利保护 10 年。  </p><p>发明和实用新型专利申请应提交的文件基本相同，即：<strong>请求书</strong>、<strong>说明书</strong>、<strong>说明书附图</strong>、<strong>权利要求书</strong>、<strong>说明书摘要</strong>及<strong>摘要附图</strong>。但某些发明专利申请可以不提交说明书附图和摘要附图。</p><p>权利要求书应当以说明书为依据，其中的权利要求应当受说明书的支持，其提出的保护范围应当与说明书中公开的内容相适应。 </p><p>摘要应当写明发明的名称、所属技术领域、要解决的技术问题、主要技术特征和用途。不得有商业性宣传用语和过多的对发明创造优点的描述。不得超过<strong>300</strong>个字。</p><p>说明书的8个部分</p><p>说明书中可以有化学式、数学式。说明书附图，应附在说明书之后。</p><p>名称应表明或反映发明是产品还是方法，例如“高光催化活性二氧化钛的制备方法”。名称还应尽量反映出发明对象的用途或应用领域。</p><p>专利说明书是以具体的技术方案为主，理论说明可有可无。 </p><h1 id="单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。"><a href="#单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。" class="headerlink" title="单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。"></a>单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 专利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的内存对齐</title>
      <link href="/2019/06/14/C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2019/06/14/C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>array &amp; string</title>
      <link href="/2019/06/13/Backtracking/"/>
      <url>/2019/06/13/Backtracking/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 724. <a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">Find Pivot Index</a></p><p>先求数组总和<code>sum</code>，然后维护一个当前数组之和 <code>cursum</code>, 然后用<code>sum</code> 减去 当前遍历到的元素，判断得到的结果是否等于2*cursum 。 </p><ul><li>等于 ， 当前位置即pivot</li><li>否则， 将当前数字加到cursum中， 继续for循环 遍历数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - nums[i] == <span class="number">2</span>*cursum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            cursum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array &amp; string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array &amp; string</title>
      <link href="/2019/06/13/array%20&amp;%20string/"/>
      <url>/2019/06/13/array%20&amp;%20string/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 724. <a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">Find Pivot Index</a></p><p>先求数组总和<code>sum</code>，然后维护一个当前数组之和 <code>cursum</code>, 然后用<code>sum</code> 减去 当前遍历到的元素，判断得到的结果是否等于2*cursum 。 </p><ul><li>等于 ， 当前位置即pivot</li><li>否则， 将当前数字加到cursum中， 继续for循环 遍历数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - nums[i] == <span class="number">2</span>*cursum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            cursum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-747-Largest-Number-At-Least-Twice-of-Others"><a href="#LeetCode-747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="LeetCode 747. Largest Number At Least Twice of Others"></a>LeetCode 747. <a href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener">Largest Number At Least Twice of Others</a></h1><p>维护两个变量<em>maxn</em> 与 <em>sec</em> 分别记录数组的最大值和次大值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN, idx = <span class="number">-1</span>, sec = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxn) &#123;</span><br><span class="line">                sec = maxn;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; sec)&#123;</span><br><span class="line">                sec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sec * <span class="number">2</span> &gt; maxn ? <span class="number">-1</span> : idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 使用 INT_MIN或 INT_MAX 会 出现问题</p><h1 id="LeetCode-66-Plus-One"><a href="#LeetCode-66-Plus-One" class="headerlink" title="LeetCode 66. Plus One"></a>LeetCode 66. <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">Plus One</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i]  != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><p>将元素插入到迭代器所指定的位置之前 （C++ primer P307）</p><h2 id="循环中break的使用"><a href="#循环中break的使用" class="headerlink" title="循环中break的使用"></a>循环中break的使用</h2><h1 id="LeetCode-498-Diagonal-Traverse"><a href="#LeetCode-498-Diagonal-Traverse" class="headerlink" title="LeetCode 498.Diagonal Traverse"></a>LeetCode 498.<a href="https://blog.csdn.net/liuchuo/article/details/54971290" target="_blank" rel="noopener">Diagonal Traverse</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-54-Spiral-Matrix"><a href="#LeetCode-54-Spiral-Matrix" class="headerlink" title="LeetCode 54.Spiral Matrix"></a>LeetCode 54.<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">Spiral Matrix</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h1 id="LeetCode-59-Spriral-Matrix-II"><a href="#LeetCode-59-Spriral-Matrix-II" class="headerlink" title="LeetCode 59.Spriral Matrix II"></a>LeetCode 59.<a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">Spriral Matrix II</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//leetcode.com/problems/spiral-matrix-ii/discuss/22409/C%2B%2B-concise-solution.</span></span><br></pre></td></tr></table></figure><h1 id="LeeteCode-118-Pascal’s-Triangle"><a href="#LeeteCode-118-Pascal’s-Triangle" class="headerlink" title="LeeteCode 118. Pascal’s Triangle"></a>LeeteCode 118. <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal’s Triangle</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array &amp; string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XOR</title>
      <link href="/2019/06/11/XOR/"/>
      <url>/2019/06/11/XOR/</url>
      
        <content type="html"><![CDATA[<h1 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a><a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1176" target="_blank" rel="noopener">Single Number</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A better explanation why this technique works-</p><p>Let’s say we have an array - [2,1,4,5,2,4,1].<br>What we are doing is essentially this-</p><p>=&gt; 0 ^ 2 ^ 1 ^ 4 ^ 5 ^ 2 ^ 4 ^ 1</p><p>=&gt; 0^ 2^2 ^ 1^1 ^ 4^4 ^5 (Rearranging, taking same numbers together)</p><p>=&gt; 0 ^ 0 ^ 0 ^ 0 ^ 5</p><p>=&gt; 0 ^ 5</p><p>=&gt; 5 :)</p><h1 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1105" target="_blank" rel="noopener">Intersection of Two Arrays</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; myset(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myset.count(num2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">                myset.erase(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用迭代器初始化set"><a href="#使用迭代器初始化set" class="headerlink" title="使用迭代器初始化set"></a>使用迭代器初始化set</h2><h2 id="从关联容器删除元素"><a href="#从关联容器删除元素" class="headerlink" title="从关联容器删除元素"></a>从关联容器删除元素</h2><p><code>c.erase(k)</code> 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除元素的数量</p><h1 id="Happy-Number-https-leetcode-com-explore-learn-card-hash-table-183-combination-with-other-algorithms-1131"><a href="#Happy-Number-https-leetcode-com-explore-learn-card-hash-table-183-combination-with-other-algorithms-1131" class="headerlink" title="[Happy Number] (https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/)"></a>[Happy Number] (<a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/" target="_blank" rel="noopener">https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/</a>)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; path;<span class="comment">//I use the map to store the result of each calculation. if 19 is the key,the value is 82:1*1+9*9=82</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> key=n;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;<span class="comment">//calculate the value of the key.</span></span><br><span class="line">            <span class="keyword">int</span> temp = n%<span class="number">10</span>;</span><br><span class="line">            value+=temp*temp;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value==<span class="number">1</span>) &#123;<span class="comment">//if the value is 1,the key is a happy number.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.count(value) &gt; <span class="number">0</span>) &#123;<span class="comment">//if the value is already in the map,there is a cycle,so the key is not a happy number.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path[key]=value;<span class="comment">//put the key/value in the map</span></span><br><span class="line">        <span class="keyword">return</span> isHappy(value);<span class="comment">//calculate recursively</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运算符 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日</title>
      <link href="/2019/06/11/%E8%BF%91%E6%97%A5/"/>
      <url>/2019/06/11/%E8%BF%91%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>leetcode 10题</li></ul><h1 id="size-与length-的区别"><a href="#size-与length-的区别" class="headerlink" title="size()与length()的区别"></a>size()与length()的区别</h1><p>C++中 二者没有区别， length()是因为沿用C语言习惯而保留下来的，string类最初只有length()，引入STL后，为了兼容又加入了size(),它是作为STL容器的属性存在的，便于用于STL算法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>subarry与subsequence</title>
      <link href="/2019/06/10/subarry%E4%B8%8Esubsequence/"/>
      <url>/2019/06/10/subarry%E4%B8%8Esubsequence/</url>
      
        <content type="html"><![CDATA[<p>subarray是截取数组中连续的一段子数组。(substring同理)</p><p>subsequence是序列中不连续的一段子序列。</p><p>[1,2,3,4,5,6]</p><p>subarray=[3,4,5];</p><p>subsequence=[2,4,5];</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>priority_queue</title>
      <link href="/2019/06/10/priority-queue/"/>
      <url>/2019/06/10/priority-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="LeeteCode-347-Top-K-Frequent-Elements"><a href="#LeeteCode-347-Top-K-Frequent-Elements" class="headerlink" title="LeeteCode 347.Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">LeeteCode 347.Top K Frequent Elements</a></h1><p>本题要注意的是语法上的东西: priority_queue 、pair</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mapNum[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : mapNum) &#123;</span><br><span class="line">            pq.push(&#123;num.second, num.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            result.push_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="range-for-中-auto-后面要不要接-amp"><a href="#range-for-中-auto-后面要不要接-amp" class="headerlink" title="range for 中 auto 后面要不要接 &amp;"></a>range for 中 auto 后面要不要接 <code>&amp;</code></h2><p>如果需要修改容器中的元素，可以使用 <code>auto&amp;</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段code是错误的，因为它向遍历的容器中添加了元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在范围for循环中向vector对象添加元素。<strong>但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加/删除元素</strong>。<em>reference</em>: 《C++ primer》 p99  p315  p316</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h3 id="first、second-是-pair-的-两个-public-数据成员"><a href="#first、second-是-pair-的-两个-public-数据成员" class="headerlink" title="first、second 是 pair 的 两个 public 数据成员"></a>first、second 是 pair 的 两个 public 数据成员</h3><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>pair&lt;string, int&gt; author{“zhhp”, 1001};</p><h3 id="用make-pair生成pair对象"><a href="#用make-pair生成pair对象" class="headerlink" title="用make_pair生成pair对象"></a>用make_pair生成pair对象</h3><p>make_pair(v1, v2) 返回一个用v1, v2初始化的pair。 pair的类型从v1和v2的类型推断出来。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash</title>
      <link href="/2019/06/05/Hash/"/>
      <url>/2019/06/05/Hash/</url>
      
        <content type="html"><![CDATA[<p>unordered_map中不存在的值会被表示为 0 ， 下面这段代码输出为  2 3<br>                                                         0 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">hashmap.insert(make_pair(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">hashmap[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hashmap[<span class="number">3</span>] &lt;&lt;<span class="string">" "</span>&lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">hashmap.erase(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span>&lt;&lt;hashmap[<span class="number">-1</span>] <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1.Two Sum"></a>LeetCode 1.<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>c.count(k) 返回关键字等于k的元素的数量，对于不允许重复关键字的容器，返回值永远是 0 或 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; towSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.count([target - nums[i]]))</span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.find(target - nums[i]) != mapNums.end()) </span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-560-Subarray-Sum-Equals-K"><a href="#LeetCode-560-Subarray-Sum-Equals-K" class="headerlink" title="LeetCode 560. Subarray Sum Equals K"></a>LeetCode 560. <a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a></h1><p>计算出从第一个数到每一个数的和，那么任意一段连续数字的和就可以通过两段和相减得出。<br>用sum表示从数组起始位置到当前位置所有数字的加和，用<code>Hash Table</code>来存储sum出现的次数，如果当前位置之前有和（prefix sum）为<code>sum - k</code>的位置，则这两个位置之间的数字之和为k。那么，以当前位置结尾，和为k的子数组个数为<code>hash[sum - k]</code>。遍历整个数组即可得出满足条件的子数组个数。<br><img src="//zhhp1001.github.io/2019/06/05/Hash/leet560.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashNums;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    hashNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">if</span> (hashNums.count(sum - k))   <span class="comment">//这个if()可以提高近一半的效率</span></span><br><span class="line">            result += hashNums[sum - k];</span><br><span class="line">        hashNums[sum]++;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下图所示，<code>if(hashNums.count(sum - k))</code> 对效率的提升是很惊人的<br><img src="//zhhp1001.github.io/2019/06/05/Hash/run.png" alt></p><p>LeetCode <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49.Group Anagrams</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mapStr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = str;</span><br><span class="line">            sort(temp.begin(), temp.end());</span><br><span class="line">            mapStr[temp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : mapStr) &#123;</span><br><span class="line">            result.push_back(str.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一个for循环处"><a href="#第一个for循环处" class="headerlink" title="第一个for循环处"></a>第一个for循环处</h2><p>能自己写出类型来就不要用auto了</p><h2 id="unordered-map-第二个类型为vector容器时的情况"><a href="#unordered-map-第二个类型为vector容器时的情况" class="headerlink" title="unordered_map 第二个类型为vector容器时的情况"></a>unordered_map 第二个类型为vector容器时的情况</h2><h2 id="使用stl的-sort函数"><a href="#使用stl的-sort函数" class="headerlink" title="使用stl的 sort函数"></a>使用stl的 sort函数</h2><p>头文件<algorithm></algorithm></p><p>语法描述 sort(begin, end, cmp)  cmp参数可以没有， 默认为非降序排序。<br><strong>cmp:</strong></p><ul><li>升序： <code>less&lt;data-type&gt;</code></li><li>降序： <code>greater&lt;data-type&gt;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">sort(a, a + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3.Longest Substring Without Repeating Characters"></a>LeetCode 3.<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></h1><h2 id="使用vector记录string中的字符是否重复"><a href="#使用vector记录string中的字符是否重复" class="headerlink" title="使用vector记录string中的字符是否重复"></a>使用vector记录string中的字符是否重复</h2><p>当 <code>dict[s[i]] &gt; start</code>时，说明在dict中 s[i]这个字符对应的索引已经被改变过， 即出现了重复的字符， 此时我们让start指向第一个重复的字符处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start ) &#123;</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxlen = max (i - start, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用unordered-map-代替上面的-定长数组"><a href="#使用unordered-map-代替上面的-定长数组" class="headerlink" title="使用unordered_map 代替上面的 定长数组"></a>使用unordered_map 代替上面的 定长数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; charMap;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charMap.count(s[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                start = max(start, charMap[s[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            charMap[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-205-Isomorphic-Strings"><a href="#LeetCode-205-Isomorphic-Strings" class="headerlink" title="LeetCode 205. Isomorphic Strings"></a>LeetCode 205. <a href="https://leetcode.com/problems/isomorphic-strings/" target="_blank" rel="noopener">Isomorphic Strings</a></h1><p>同构字符串。我们用两个哈希表分别来记录两个字符串中字符出现的情况，由于ASCII只有256个字符，所以我们用一个大小为256的数组来代替哈希表，并初始化为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> b[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s[i]] != b[t[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            b[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把上面的数组换成stl中的哈希表也是一样的（unordered_map&lt;char, int&gt;）。<br>这段代码的精髓在于 <code>a[s[i]] = i + 1;</code> 和 <code>b[t[i]] = i + 1;</code> ， 这里i + 1 相当于让不同位置的字符有不同的索引，避免了将<em>aba</em>, <em>baa</em>这样的string误判为同构。</p><h1 id="LeetCode-Minimum-Index-Sum-of-Two-Lists"><a href="#LeetCode-Minimum-Index-Sum-of-Two-Lists" class="headerlink" title="LeetCode Minimum Index Sum of Two Lists"></a>LeetCode <a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">Minimum Index Sum of Two Lists</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); i++) &#123;</span><br><span class="line">            hashmap[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.count(list2[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; i + hashmap[list2[i]]) &#123;</span><br><span class="line">                    min = i + hashmap[list2[i]];</span><br><span class="line">                    result.clear();</span><br><span class="line">                    result.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == i + hashmap[list2[i]]) &#123;</span><br><span class="line">                    result.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="clear-清空所有元素"><a href="#clear-清空所有元素" class="headerlink" title="clear() 清空所有元素"></a>clear() 清空所有元素</h2><h2 id="C-C-整型的上下限-INT-MAX-INT-MIN"><a href="#C-C-整型的上下限-INT-MAX-INT-MIN" class="headerlink" title="C/C++ 整型的上下限 INT_MAX INT_MIN"></a>C/C++ 整型的上下限 INT_MAX INT_MIN</h2><p>int 占 4字节 32位， 因此：<br>INT_MAX = 2<sup>31</sup> - 1<br>INT_MIN = -2<sup>31</sup></p><p>Leetcode 349.<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num1 : nums1) &#123;</span><br><span class="line">            hashmap[num1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap[num2] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">                hashmap[num2]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二个for循环处 if(hashmap[num2] &gt; 0) 不可以替换成 hashmap.count(num2)。 因为<code>count(key)</code>函数是用以统计key在unordered_map中出现的次数，而unordered_map不允许存在重复的key，因此，如果key存在，则count(key) 返回 1， 否则 返回 0。 这里我犯的错误属于 对count(key) 功能的 认知错误。</p><h1 id="LeetCode-219-Contains-Duplicate-II"><a href="#LeetCode-219-Contains-Duplicate-II" class="headerlink" title="LeetCode 219.Contains Duplicate II"></a>LeetCode 219.<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></h1><p>此题错在读题不仔细， 没有意识到<em>at most</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.count(nums[i]) ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i - hashmap[nums[i]]) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构与算法-unordered_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历（C++实现）</title>
      <link href="/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义二叉树结点类"><a href="#定义二叉树结点类" class="headerlink" title="定义二叉树结点类"></a>定义二叉树结点类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BnaryTreeNode* lc;</span><br><span class="line">    BinaryTreeNode* rc;</span><br><span class="line">    BinaryTreeNode (<span class="keyword">int</span> cont&amp; _val, BinaryTreeNode* _lc = <span class="literal">nullptr</span>, BinaryTreeNode* _rc = <span class="literal">nullptr</span>) : </span><br><span class="line">    val(_val), lc(_lc), rc(_rc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先序遍历、中序遍历、后序遍历<strong>访问节点</strong>的顺序是一致的， 不同之处在于处理节点的顺序。有的遍历流程把访问到的节点暂存起来，达成某种条件后再对其进行处理（比如输出），我们约定，根节点V、左孩子L、右孩子R，那么遍历顺序可以记为：</p><ul><li>先序遍历VLR：到达一个节点后，即刻输出该节点的值，并继续遍历其左、右子树。</li><li>中序遍历LVR：到达一个节点后，先将该节点暂存，遍历完其左子树后，再输出该节点的值，然后遍历其右子树。</li><li>后序遍历LRV： 到达一个节点后，先将该节点暂存，遍历完其左右子树后，再输出该节点的值。</li></ul><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="先序遍历（VLR）"><a href="#先序遍历（VLR）" class="headerlink" title="先序遍历（VLR）"></a>先序遍历（VLR）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>与先序遍历类似，唯一区别是到达该节点时，并不直接输出该节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已遍历完成。 因此， 我们需要设置一个<strong>lastvisit指针</strong>，若lastvisit指向当前节点的右孩子，表示该节点的左右子树都已遍历完成，可以输出当前节点 （否则，继续探索当前节点的右子树）， 并使lastvisit指向当前节点， 将当前节点（指针）设置为空（这样，下一轮循环就可以访问栈顶元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    BinaryTreeNode* lastvisit = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;rc == <span class="literal">nullptr</span> || root-&gt;rc == lastvisit) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                lastvisit = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
