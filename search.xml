<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>二叉树的遍历（C++实现）</title>
      <link href="/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义二叉树结点类"><a href="#定义二叉树结点类" class="headerlink" title="定义二叉树结点类"></a>定义二叉树结点类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BnaryTreeNode* lc;</span><br><span class="line">    BinaryTreeNode* rc;</span><br><span class="line">    BinaryTreeNode (<span class="keyword">int</span> cont&amp; _val, BinaryTreeNode* _lc = <span class="literal">nullptr</span>, BinaryTreeNode* _rc = <span class="literal">nullptr</span>) : </span><br><span class="line">    val(_val), lc(_lc), rc(_rc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先序遍历、中序遍历、后序遍历<strong>访问节点</strong>的顺序是一致的， 不同之处在于处理节点的顺序。有的遍历流程把访问到的节点暂存起来，达成某种条件后再对其进行处理（比如输出），我们约定，根节点V、左孩子L、右孩子R，那么遍历顺序可以记为：</p><ul><li>先序遍历VLR：到达一个节点后，即刻输出该节点的值，并继续遍历其左、右子树。</li><li>中序遍历LVR：到达一个节点后，先将该节点暂存，遍历完其左子树后，再输出该节点的值，然后遍历其右子树。</li><li>后序遍历LRV： 到达一个节点后，先将该节点暂存，遍历完其左右子树后，再输出该节点的值。</li></ul><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="先序遍历（VLR）"><a href="#先序遍历（VLR）" class="headerlink" title="先序遍历（VLR）"></a>先序遍历（VLR）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>与先序遍历类似，唯一区别是到达该节点时，并不直接输出该节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已遍历完成。 因此， 我们需要设置一个<strong>lastvisit指针</strong>，若lastvisit指向当前节点的右孩子，表示该节点的左右子树都已遍历完成，可以输出当前节点 （否则，继续探索当前节点的右子树）， 并使lastvisit指向当前节点， 将当前节点（指针）设置为空（这样，下一轮循环就可以访问栈顶元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    BinaryTreeNode* lastvisit = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;rc == <span class="literal">nullptr</span> || root-&gt;rc == lastvisit) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                lastvisit = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
