<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sort</title>
      <link href="/2019/06/23/sort/"/>
      <url>/2019/06/23/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p><img src="//zhhp1001.github.io/2019/06/23/sort/insert.gif" alt><br>每次把一个新数据插入到有序队列中的合适位置里。</p><p>假设有一组无序序列 R<sub>0</sub>, R<sub>1</sub>, … , R<sub>N-1</sub>。</p><p>(1) 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。</p><p>(2) 然后，我们要依次把  R<sub>0</sub>, R<sub>1</sub>, … , R<sub>N-1</sub> 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。</p><p>(3) 接下来描述插入过程。假设这是要将 R<sub>i</sub> 插入到前面有序的序列中。由前面所述，我们可知，插入 R<sub>i</sub>时，前 i-1 个数肯定已经是有序了。</p><p>所以我们需要将 R<sub>i</sub> 和R<sub>0</sub> ~  R<sub>i-1</sub> 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insertionSort(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (input.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = result[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--) &#123;</span><br><span class="line">result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : iv) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve = insertionSort(iv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solve.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>每趟从待排序的序列中选出最小的元素，顺序放在已排序的序列末尾。</p><ul><li>从待排序序列中，找到关键字最小的元素；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。<br><img src="//zhhp1001.github.io/2019/06/23/sort/select.gif" alt></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selectSort(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (input.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; result.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[index] &gt; result[j]) &#123;</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == i) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(result[index], result[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"次循环:  "</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : result) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前 ："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : iv) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve = selectSort(iv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>快速排序的精髓在于partition()，我们把第一个元素作为pivot的培养对象，经过一次partition()后，数组分为两部分，第一部分<code>&lt;=</code>pivot,第二部分<code>&gt;=</code>pivot。<br>快速排序算法需要两个指针 i、j 分别指向数组的两端， i之前的元素 <code>&lt;=</code>pivot, j之后的元素 <code>&gt;=</code>pivot。两个指针向中间移动，直到遇到一个不符合条件的元素才停止移动。当两个指针都停下时，交换i 、 j 指针指向的元素。<br>重复这个过程。</p><p><img src="//zhhp1001.github.io/2019/06/23/sort/quick.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt;= pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &gt;= pivot) j--;</span><br><span class="line">    swap(a[i], a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了循环就自然要考虑循环的终止条件。可以发现，当i、j两个指针穷尽了各自的区间时循环应该停止， 此时两指针处于 <strong>交错状态</strong>，i指向 <code>&gt;=</code>区域的第一个元素， j指向<code>&lt;=</code>区域的最后一个元素。<br><img src="//zhhp1001.github.io/2019/06/23/sort/sort2.png" alt><br>此时不应该再进行交换操作了。 这时，我们把pivot移动到j处，并且return j这位置， 这样，一次partition操作就完成了。<br>关于i、j两个指针的while循环有数组越界的危险， 假设所有元素都&lt;=pivot， 那么i会越界；假设所有元素都&gt;=pivot，那么j会越界。因此要加上<code>i&lt;=j</code>这个判断来避免越界（注意要有<code>=</code>， 保证i、j会交错）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = first;</span><br><span class="line">    <span class="keyword">int</span> j = last;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[first];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=j &amp;&amp; a[i] &gt;= pivot) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        swap (a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap (a[first],a[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是完整的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = first;</span><br><span class="line"><span class="keyword">int</span> j = last;</span><br><span class="line"><span class="keyword">int</span> p = first;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; vec[i] &lt;= vec[p]) i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; vec[j] &gt;= vec[p]) j--;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">swap(vec[i], vec[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">swap(vec[p], vec[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (last &gt; first) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot = partition(vec, first, last);</span><br><span class="line">quickSort (vec, first, pivot - <span class="number">1</span>);</span><br><span class="line">quickSort (vec, pivot + <span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前： "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : input) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后： "</span>;</span><br><span class="line">quickSort(input, <span class="number">0</span>, input.size() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : input) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><h1 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h1>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影调</title>
      <link href="/2019/06/18/%E5%BD%B1%E8%B0%83/"/>
      <url>/2019/06/18/%E5%BD%B1%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<p>黑白明暗层次变化是影像的骨架和节奏，而色彩则是附着其上的血肉和韵律。亚当斯把0<del>255这个颜色范围分成了0</del>X十一个区，其中0和X分别是纯黑纯白，</p><ul><li>从全黑到全白的0区~X区是<em>全影调幅度</em>；</li><li>I区~IX区是具有基本影调值的<em>有效幅度</em>；</li><li>II~VIII是能够清晰地表现出影调纹理质感的<em>纹理幅度</em>。<img src="//zhhp1001.github.io/2019/06/18/影调/%E4%BA%9A%E5%BD%93%E6%96%AF.png" alt></li></ul><h1 id="影调的划分"><a href="#影调的划分" class="headerlink" title="影调的划分"></a>影调的划分</h1><h2 id="根据画面明暗基调关系划分影调"><a href="#根据画面明暗基调关系划分影调" class="headerlink" title="根据画面明暗基调关系划分影调"></a>根据画面明暗基调关系划分影调</h2><p>对于影调，我们首先可以根据画面中的明暗基调关系（黑白关系）进行划分。在灰阶的11个区域中，0代表纯黑，10代表纯白，我们可以把11级分为低明度、中明度、高明度3个级别。<br><img src="//zhhp1001.github.io/2019/06/18/影调/%E6%98%8E%E6%9A%97.png" alt></p><ul><li>低调（暗调），给人神秘、含蓄、肃穆、庄重、粗豪、倔强和力量的视觉感受。低调形成的基础为黑色，但照片并不是黑成一篇，必须在相应的位置辅以亮色（高光），正因为有大片的暗色调烘托陪衬，小面积的亮色就会显得突出而成为整个画面的视觉中心。</li><li>中调（灰调），有平和与疏淡的感觉。</li><li>高调（亮调），视觉感受为轻盈、纯洁、明快、清秀、宁静、淡雅与舒适。高调照片在浅而苏雅的影调环境中，局部少量的暗色也是必不可少的，这些黑暗影调所构成的部分往往成为画面的视觉中心。<h2 id="根据画面明度对比强弱划分影调"><a href="#根据画面明度对比强弱划分影调" class="headerlink" title="根据画面明度对比强弱划分影调"></a>根据画面明度对比强弱划分影调</h2>在一张照片中，如果明暗灰阶相差5级以上，称为<strong>长调</strong>，画面对比很强烈。相差3~5级以内，称为短调，画面对比很弱，整体层次比较平淡。</li></ul><p>P240</p>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从对象切割说起</title>
      <link href="/2019/06/18/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2%E8%AF%B4%E8%B5%B7/"/>
      <url>/2019/06/18/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临时对象</title>
      <link href="/2019/06/18/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/06/18/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>临时对象（由编译器定义的一个没有命名的非堆（non-heap）对象），不出现在C++代码中，但是确实存在。这种未命名对象有两种产生条件：</p><ul><li>为了使函数调用成功而进行的隐式类型转换。</li><li>函数返回对象。</li></ul><h1 id="C-中对临时变量的引用必须是-const引用。"><a href="#C-中对临时变量的引用必须是-const引用。" class="headerlink" title="C++ 中对临时变量的引用必须是 const引用。"></a>C++ 中对临时变量的引用必须是 const引用。</h1><p>如果一个参数是以一个非const 引用 传入的，那么C++编译器就有理由相信我们传入的参数在函数中是可以被修改的，并且这个修改的变量在函数外也是可以使用的；如果我们把一个<strong>临时对象</strong>当作非const引用参数传进来，则由于对临时变量的修改在函数内部，临时变量在使用完成后就被释放，所以我们修改一个临时变量实际上是<strong>没有意义</strong>的，因此，C++编译器就加入了临时变量不能作为非const引用的这个语义限制。<br>在编译器告诉你错误比在运行期时遇到问题更为友好。</p>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack object / heap object</title>
      <link href="/2019/06/17/stack-object-heap-object/"/>
      <url>/2019/06/17/stack-object-heap-object/</url>
      
        <content type="html"><![CDATA[<h1 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h1><h1 id="栈对象"><a href="#栈对象" class="headerlink" title="栈对象"></a>栈对象</h1><pre><code>由编译器自动分配和释放， 用于保存一些局部变量、函数的参数等。</code></pre><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><p>栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要我们来费心；而且，栈对象的创建速度比堆对象快，因为分配堆对象时会调用 operator new操作， operator new 会采用某种内存空间搜索算法， 而该搜索过程可能很费时间， 栈对象的产生则仅仅需要移动栈顶指针。 但要注意， 栈空间容量较小（1~2M），所以体积较大的对象不适合在栈中分配，特别要注意递归函数最好不要使用栈对象，因为随着递归深度的增加，所需栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，产生运行时错误。</p></li><li><p>因此，当你明确要使用的类型数量时， 使用 Object objec;<br>当你不知道你要创建的类型有多少个时， 使用 Object* object = new Object();</p></li><li><p>栈对象相当于局部对象，堆对象相当于一种能共享于各函数或语句块的对象。栈对象在语句块执行完就自动销毁，堆对象需要手动销毁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专利</title>
      <link href="/2019/06/17/%E4%B8%93%E5%88%A9/"/>
      <url>/2019/06/17/%E4%B8%93%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="实用新型专利"><a href="#实用新型专利" class="headerlink" title="实用新型专利"></a>实用新型专利</h1><p>只要有一些技术改进就可以申请实用新型专利，要注意的是，只有设计产品构造、形状或其结合时，才可申请实用新型专利。实用新型专利保护 10 年。  </p><p>发明和实用新型专利申请应提交的文件基本相同，即：<strong>请求书</strong>、<strong>说明书</strong>、<strong>说明书附图</strong>、<strong>权利要求书</strong>、<strong>说明书摘要</strong>及<strong>摘要附图</strong>。但某些发明专利申请可以不提交说明书附图和摘要附图。</p><p>权利要求书应当以说明书为依据，其中的权利要求应当受说明书的支持，其提出的保护范围应当与说明书中公开的内容相适应。 </p><p>摘要应当写明发明的名称、所属技术领域、要解决的技术问题、主要技术特征和用途。不得有商业性宣传用语和过多的对发明创造优点的描述。不得超过<strong>300</strong>个字。</p><p>说明书的8个部分</p><p>说明书中可以有化学式、数学式。说明书附图，应附在说明书之后。</p><p>名称应表明或反映发明是产品还是方法，例如“高光催化活性二氧化钛的制备方法”。名称还应尽量反映出发明对象的用途或应用领域。</p><p>专利说明书是以具体的技术方案为主，理论说明可有可无。 </p><h1 id="单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。"><a href="#单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。" class="headerlink" title="单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。"></a>单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 专利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的内存对齐</title>
      <link href="/2019/06/14/C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2019/06/14/C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>array &amp; string</title>
      <link href="/2019/06/13/Backtracking/"/>
      <url>/2019/06/13/Backtracking/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 724. <a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">Find Pivot Index</a></p><p>先求数组总和<code>sum</code>，然后维护一个当前数组之和 <code>cursum</code>, 然后用<code>sum</code> 减去 当前遍历到的元素，判断得到的结果是否等于2*cursum 。 </p><ul><li>等于 ， 当前位置即pivot</li><li>否则， 将当前数字加到cursum中， 继续for循环 遍历数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - nums[i] == <span class="number">2</span>*cursum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            cursum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array &amp; string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array &amp; string</title>
      <link href="/2019/06/13/array%20&amp;%20string/"/>
      <url>/2019/06/13/array%20&amp;%20string/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 724. <a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">Find Pivot Index</a></p><p>先求数组总和<code>sum</code>，然后维护一个当前数组之和 <code>cursum</code>, 然后用<code>sum</code> 减去 当前遍历到的元素，判断得到的结果是否等于2*cursum 。 </p><ul><li>等于 ， 当前位置即pivot</li><li>否则， 将当前数字加到cursum中， 继续for循环 遍历数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - nums[i] == <span class="number">2</span>*cursum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            cursum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-747-Largest-Number-At-Least-Twice-of-Others"><a href="#LeetCode-747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="LeetCode 747. Largest Number At Least Twice of Others"></a>LeetCode 747. <a href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener">Largest Number At Least Twice of Others</a></h1><p>维护两个变量<em>maxn</em> 与 <em>sec</em> 分别记录数组的最大值和次大值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN, idx = <span class="number">-1</span>, sec = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxn) &#123;</span><br><span class="line">                sec = maxn;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; sec)&#123;</span><br><span class="line">                sec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sec * <span class="number">2</span> &gt; maxn ? <span class="number">-1</span> : idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 使用 INT_MIN或 INT_MAX 会 出现问题</p><h1 id="LeetCode-66-Plus-One"><a href="#LeetCode-66-Plus-One" class="headerlink" title="LeetCode 66. Plus One"></a>LeetCode 66. <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">Plus One</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i]  != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><p>将元素插入到迭代器所指定的位置之前 （C++ primer P307）</p><h2 id="循环中break的使用"><a href="#循环中break的使用" class="headerlink" title="循环中break的使用"></a>循环中break的使用</h2><h1 id="LeetCode-498-Diagonal-Traverse"><a href="#LeetCode-498-Diagonal-Traverse" class="headerlink" title="LeetCode 498.Diagonal Traverse"></a>LeetCode 498.<a href="https://blog.csdn.net/liuchuo/article/details/54971290" target="_blank" rel="noopener">Diagonal Traverse</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-54-Spiral-Matrix"><a href="#LeetCode-54-Spiral-Matrix" class="headerlink" title="LeetCode 54.Spiral Matrix"></a>LeetCode 54.<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">Spiral Matrix</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h1 id="LeetCode-59-Spriral-Matrix-II"><a href="#LeetCode-59-Spriral-Matrix-II" class="headerlink" title="LeetCode 59.Spriral Matrix II"></a>LeetCode 59.<a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">Spriral Matrix II</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//leetcode.com/problems/spiral-matrix-ii/discuss/22409/C%2B%2B-concise-solution.</span></span><br></pre></td></tr></table></figure><h1 id="LeeteCode-118-Pascal’s-Triangle"><a href="#LeeteCode-118-Pascal’s-Triangle" class="headerlink" title="LeeteCode 118. Pascal’s Triangle"></a>LeeteCode 118. <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal’s Triangle</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array &amp; string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XOR</title>
      <link href="/2019/06/11/XOR/"/>
      <url>/2019/06/11/XOR/</url>
      
        <content type="html"><![CDATA[<h1 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a><a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1176" target="_blank" rel="noopener">Single Number</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A better explanation why this technique works-</p><p>Let’s say we have an array - [2,1,4,5,2,4,1].<br>What we are doing is essentially this-</p><p>=&gt; 0 ^ 2 ^ 1 ^ 4 ^ 5 ^ 2 ^ 4 ^ 1</p><p>=&gt; 0^ 2^2 ^ 1^1 ^ 4^4 ^5 (Rearranging, taking same numbers together)</p><p>=&gt; 0 ^ 0 ^ 0 ^ 0 ^ 5</p><p>=&gt; 0 ^ 5</p><p>=&gt; 5 :)</p><h1 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1105" target="_blank" rel="noopener">Intersection of Two Arrays</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; myset(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myset.count(num2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">                myset.erase(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用迭代器初始化set"><a href="#使用迭代器初始化set" class="headerlink" title="使用迭代器初始化set"></a>使用迭代器初始化set</h2><h2 id="从关联容器删除元素"><a href="#从关联容器删除元素" class="headerlink" title="从关联容器删除元素"></a>从关联容器删除元素</h2><p><code>c.erase(k)</code> 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除元素的数量</p><h1 id="Happy-Number-https-leetcode-com-explore-learn-card-hash-table-183-combination-with-other-algorithms-1131"><a href="#Happy-Number-https-leetcode-com-explore-learn-card-hash-table-183-combination-with-other-algorithms-1131" class="headerlink" title="[Happy Number] (https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/)"></a>[Happy Number] (<a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/" target="_blank" rel="noopener">https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/</a>)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; path;<span class="comment">//I use the map to store the result of each calculation. if 19 is the key,the value is 82:1*1+9*9=82</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> key=n;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;<span class="comment">//calculate the value of the key.</span></span><br><span class="line">            <span class="keyword">int</span> temp = n%<span class="number">10</span>;</span><br><span class="line">            value+=temp*temp;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value==<span class="number">1</span>) &#123;<span class="comment">//if the value is 1,the key is a happy number.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.count(value) &gt; <span class="number">0</span>) &#123;<span class="comment">//if the value is already in the map,there is a cycle,so the key is not a happy number.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path[key]=value;<span class="comment">//put the key/value in the map</span></span><br><span class="line">        <span class="keyword">return</span> isHappy(value);<span class="comment">//calculate recursively</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运算符 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日</title>
      <link href="/2019/06/11/%E8%BF%91%E6%97%A5/"/>
      <url>/2019/06/11/%E8%BF%91%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>leetcode 10题</li></ul><h1 id="size-与length-的区别"><a href="#size-与length-的区别" class="headerlink" title="size()与length()的区别"></a>size()与length()的区别</h1><p>C++中 二者没有区别， length()是因为沿用C语言习惯而保留下来的，string类最初只有length()，引入STL后，为了兼容又加入了size(),它是作为STL容器的属性存在的，便于用于STL算法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>subarry与subsequence</title>
      <link href="/2019/06/10/subarry%E4%B8%8Esubsequence/"/>
      <url>/2019/06/10/subarry%E4%B8%8Esubsequence/</url>
      
        <content type="html"><![CDATA[<p>subarray是截取数组中连续的一段子数组。(substring同理)</p><p>subsequence是序列中不连续的一段子序列。</p><p>[1,2,3,4,5,6]</p><p>subarray=[3,4,5];</p><p>subsequence=[2,4,5];</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>priority_queue</title>
      <link href="/2019/06/10/priority-queue/"/>
      <url>/2019/06/10/priority-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="LeeteCode-347-Top-K-Frequent-Elements"><a href="#LeeteCode-347-Top-K-Frequent-Elements" class="headerlink" title="LeeteCode 347.Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">LeeteCode 347.Top K Frequent Elements</a></h1><p>本题要注意的是语法上的东西: priority_queue 、pair</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mapNum[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : mapNum) &#123;</span><br><span class="line">            pq.push(&#123;num.second, num.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            result.push_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="range-for-中-auto-后面要不要接-amp"><a href="#range-for-中-auto-后面要不要接-amp" class="headerlink" title="range for 中 auto 后面要不要接 &amp;"></a>range for 中 auto 后面要不要接 <code>&amp;</code></h2><p>如果需要修改容器中的元素，可以使用 <code>auto&amp;</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段code是错误的，因为它向遍历的容器中添加了元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在范围for循环中向vector对象添加元素。<strong>但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加/删除元素</strong>。<em>reference</em>: 《C++ primer》 p99  p315  p316</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h3 id="first、second-是-pair-的-两个-public-数据成员"><a href="#first、second-是-pair-的-两个-public-数据成员" class="headerlink" title="first、second 是 pair 的 两个 public 数据成员"></a>first、second 是 pair 的 两个 public 数据成员</h3><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>pair&lt;string, int&gt; author{“zhhp”, 1001};</p><h3 id="用make-pair生成pair对象"><a href="#用make-pair生成pair对象" class="headerlink" title="用make_pair生成pair对象"></a>用make_pair生成pair对象</h3><p>make_pair(v1, v2) 返回一个用v1, v2初始化的pair。 pair的类型从v1和v2的类型推断出来。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash</title>
      <link href="/2019/06/05/Hash/"/>
      <url>/2019/06/05/Hash/</url>
      
        <content type="html"><![CDATA[<p>unordered_map中不存在的值会被表示为 0 ， 下面这段代码输出为  2 3<br>                                                         0 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">hashmap.insert(make_pair(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">hashmap[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hashmap[<span class="number">3</span>] &lt;&lt;<span class="string">" "</span>&lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">hashmap.erase(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span>&lt;&lt;hashmap[<span class="number">-1</span>] <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1.Two Sum"></a>LeetCode 1.<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>c.count(k) 返回关键字等于k的元素的数量，对于不允许重复关键字的容器，返回值永远是 0 或 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; towSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.count([target - nums[i]]))</span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.find(target - nums[i]) != mapNums.end()) </span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-560-Subarray-Sum-Equals-K"><a href="#LeetCode-560-Subarray-Sum-Equals-K" class="headerlink" title="LeetCode 560. Subarray Sum Equals K"></a>LeetCode 560. <a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a></h1><p>计算出从第一个数到每一个数的和，那么任意一段连续数字的和就可以通过两段和相减得出。<br>用sum表示从数组起始位置到当前位置所有数字的加和，用<code>Hash Table</code>来存储sum出现的次数，如果当前位置之前有和（prefix sum）为<code>sum - k</code>的位置，则这两个位置之间的数字之和为k。那么，以当前位置结尾，和为k的子数组个数为<code>hash[sum - k]</code>。遍历整个数组即可得出满足条件的子数组个数。<br><img src="//zhhp1001.github.io/2019/06/05/Hash/leet560.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashNums;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    hashNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">if</span> (hashNums.count(sum - k))   <span class="comment">//这个if()可以提高近一半的效率</span></span><br><span class="line">            result += hashNums[sum - k];</span><br><span class="line">        hashNums[sum]++;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下图所示，<code>if(hashNums.count(sum - k))</code> 对效率的提升是很惊人的<br><img src="//zhhp1001.github.io/2019/06/05/Hash/run.png" alt></p><p>LeetCode <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49.Group Anagrams</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mapStr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = str;</span><br><span class="line">            sort(temp.begin(), temp.end());</span><br><span class="line">            mapStr[temp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : mapStr) &#123;</span><br><span class="line">            result.push_back(str.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一个for循环处"><a href="#第一个for循环处" class="headerlink" title="第一个for循环处"></a>第一个for循环处</h2><p>能自己写出类型来就不要用auto了</p><h2 id="unordered-map-第二个类型为vector容器时的情况"><a href="#unordered-map-第二个类型为vector容器时的情况" class="headerlink" title="unordered_map 第二个类型为vector容器时的情况"></a>unordered_map 第二个类型为vector容器时的情况</h2><h2 id="使用stl的-sort函数"><a href="#使用stl的-sort函数" class="headerlink" title="使用stl的 sort函数"></a>使用stl的 sort函数</h2><p>头文件<algorithm></algorithm></p><p>语法描述 sort(begin, end, cmp)  cmp参数可以没有， 默认为非降序排序。<br><strong>cmp:</strong></p><ul><li>升序： <code>less&lt;data-type&gt;</code></li><li>降序： <code>greater&lt;data-type&gt;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">sort(a, a + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3.Longest Substring Without Repeating Characters"></a>LeetCode 3.<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></h1><h2 id="使用vector记录string中的字符是否重复"><a href="#使用vector记录string中的字符是否重复" class="headerlink" title="使用vector记录string中的字符是否重复"></a>使用vector记录string中的字符是否重复</h2><p>当 <code>dict[s[i]] &gt; start</code>时，说明在dict中 s[i]这个字符对应的索引已经被改变过， 即出现了重复的字符， 此时我们让start指向第一个重复的字符处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start ) &#123;</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxlen = max (i - start, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用unordered-map-代替上面的-定长数组"><a href="#使用unordered-map-代替上面的-定长数组" class="headerlink" title="使用unordered_map 代替上面的 定长数组"></a>使用unordered_map 代替上面的 定长数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; charMap;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charMap.count(s[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                start = max(start, charMap[s[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            charMap[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-205-Isomorphic-Strings"><a href="#LeetCode-205-Isomorphic-Strings" class="headerlink" title="LeetCode 205. Isomorphic Strings"></a>LeetCode 205. <a href="https://leetcode.com/problems/isomorphic-strings/" target="_blank" rel="noopener">Isomorphic Strings</a></h1><p>同构字符串。我们用两个哈希表分别来记录两个字符串中字符出现的情况，由于ASCII只有256个字符，所以我们用一个大小为256的数组来代替哈希表，并初始化为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> b[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s[i]] != b[t[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            b[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把上面的数组换成stl中的哈希表也是一样的（unordered_map&lt;char, int&gt;）。<br>这段代码的精髓在于 <code>a[s[i]] = i + 1;</code> 和 <code>b[t[i]] = i + 1;</code> ， 这里i + 1 相当于让不同位置的字符有不同的索引，避免了将<em>aba</em>, <em>baa</em>这样的string误判为同构。</p><h1 id="LeetCode-Minimum-Index-Sum-of-Two-Lists"><a href="#LeetCode-Minimum-Index-Sum-of-Two-Lists" class="headerlink" title="LeetCode Minimum Index Sum of Two Lists"></a>LeetCode <a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">Minimum Index Sum of Two Lists</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); i++) &#123;</span><br><span class="line">            hashmap[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.count(list2[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; i + hashmap[list2[i]]) &#123;</span><br><span class="line">                    min = i + hashmap[list2[i]];</span><br><span class="line">                    result.clear();</span><br><span class="line">                    result.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == i + hashmap[list2[i]]) &#123;</span><br><span class="line">                    result.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="clear-清空所有元素"><a href="#clear-清空所有元素" class="headerlink" title="clear() 清空所有元素"></a>clear() 清空所有元素</h2><h2 id="C-C-整型的上下限-INT-MAX-INT-MIN"><a href="#C-C-整型的上下限-INT-MAX-INT-MIN" class="headerlink" title="C/C++ 整型的上下限 INT_MAX INT_MIN"></a>C/C++ 整型的上下限 INT_MAX INT_MIN</h2><p>int 占 4字节 32位， 因此：<br>INT_MAX = 2<sup>31</sup> - 1<br>INT_MIN = -2<sup>31</sup></p><p>Leetcode 349.<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num1 : nums1) &#123;</span><br><span class="line">            hashmap[num1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap[num2] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">                hashmap[num2]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二个for循环处 if(hashmap[num2] &gt; 0) 不可以替换成 hashmap.count(num2)。 因为<code>count(key)</code>函数是用以统计key在unordered_map中出现的次数，而unordered_map不允许存在重复的key，因此，如果key存在，则count(key) 返回 1， 否则 返回 0。 这里我犯的错误属于 对count(key) 功能的 认知错误。</p><h1 id="LeetCode-219-Contains-Duplicate-II"><a href="#LeetCode-219-Contains-Duplicate-II" class="headerlink" title="LeetCode 219.Contains Duplicate II"></a>LeetCode 219.<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></h1><p>此题错在读题不仔细， 没有意识到<em>at most</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.count(nums[i]) ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i - hashmap[nums[i]]) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构与算法-unordered_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历（C++实现）</title>
      <link href="/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义二叉树结点类"><a href="#定义二叉树结点类" class="headerlink" title="定义二叉树结点类"></a>定义二叉树结点类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BnaryTreeNode* lc;</span><br><span class="line">    BinaryTreeNode* rc;</span><br><span class="line">    BinaryTreeNode (<span class="keyword">int</span> cont&amp; _val, BinaryTreeNode* _lc = <span class="literal">nullptr</span>, BinaryTreeNode* _rc = <span class="literal">nullptr</span>) : </span><br><span class="line">    val(_val), lc(_lc), rc(_rc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先序遍历、中序遍历、后序遍历<strong>访问节点</strong>的顺序是一致的， 不同之处在于处理节点的顺序。有的遍历流程把访问到的节点暂存起来，达成某种条件后再对其进行处理（比如输出），我们约定，根节点V、左孩子L、右孩子R，那么遍历顺序可以记为：</p><ul><li>先序遍历VLR：到达一个节点后，即刻输出该节点的值，并继续遍历其左、右子树。</li><li>中序遍历LVR：到达一个节点后，先将该节点暂存，遍历完其左子树后，再输出该节点的值，然后遍历其右子树。</li><li>后序遍历LRV： 到达一个节点后，先将该节点暂存，遍历完其左右子树后，再输出该节点的值。</li></ul><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="先序遍历（VLR）"><a href="#先序遍历（VLR）" class="headerlink" title="先序遍历（VLR）"></a>先序遍历（VLR）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>与先序遍历类似，唯一区别是到达该节点时，并不直接输出该节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已遍历完成。 因此， 我们需要设置一个<strong>lastvisit指针</strong>，若lastvisit指向当前节点的右孩子，表示该节点的左右子树都已遍历完成，可以输出当前节点 （否则，继续探索当前节点的右子树）， 并使lastvisit指向当前节点， 将当前节点（指针）设置为空（这样，下一轮循环就可以访问栈顶元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    BinaryTreeNode* lastvisit = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;rc == <span class="literal">nullptr</span> || root-&gt;rc == lastvisit) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                lastvisit = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
