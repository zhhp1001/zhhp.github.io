<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>priority_queue</title>
      <link href="/2019/06/10/priority-queue/"/>
      <url>/2019/06/10/priority-queue/</url>
      
        <content type="html"><![CDATA[<h1 id="LeeteCode-347-Top-K-Frequent-Elements"><a href="#LeeteCode-347-Top-K-Frequent-Elements" class="headerlink" title="LeeteCode 347.Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">LeeteCode 347.Top K Frequent Elements</a></h1><p>本题要注意的是语法上的东西: priority_queue 、pair</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mapNum[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : mapNum) &#123;</span><br><span class="line">            pq.push(&#123;num.second, num.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            result.push_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="range-for-中-auto-后面要不要接-amp"><a href="#range-for-中-auto-后面要不要接-amp" class="headerlink" title="range for 中 auto 后面要不要接 &amp;"></a>range for 中 auto 后面要不要接 <code>&amp;</code></h2><p>如果需要修改容器中的元素，可以使用 <code>auto&amp;</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段code是错误的，因为它向遍历的容器中添加了元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在范围for循环中向vector对象添加元素。<strong>但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加/删除元素</strong>。<em>reference</em>: 《C++ primer》 p99  p315  p316</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h3 id="first、second-是-pair-的-两个-public-数据成员"><a href="#first、second-是-pair-的-两个-public-数据成员" class="headerlink" title="first、second 是 pair 的 两个 public 数据成员"></a>first、second 是 pair 的 两个 public 数据成员</h3><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>pair&lt;string, int&gt; author{“zhhp”, 1001};</p><h3 id="用make-pair生成pair对象"><a href="#用make-pair生成pair对象" class="headerlink" title="用make_pair生成pair对象"></a>用make_pair生成pair对象</h3><p>make_pair(v1, v2) 返回一个用v1, v2初始化的pair。 pair的类型从v1和v2的类型推断出来。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash</title>
      <link href="/2019/06/05/Hash/"/>
      <url>/2019/06/05/Hash/</url>
      
        <content type="html"><![CDATA[<h1 id="LeeteCode-1-Two-Sum"><a href="#LeeteCode-1-Two-Sum" class="headerlink" title="LeeteCode 1.Two Sum"></a>LeeteCode 1.<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>c.count(k) 返回关键字等于k的元素的数量，对于不允许重复关键字的容器，返回值永远是 0 或 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; towSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.count([target - nums[i]]))</span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.find(target - nums[i]) != mapNums.end()) </span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeeteCode-560-Subarray-Sum-Equals-K"><a href="#LeeteCode-560-Subarray-Sum-Equals-K" class="headerlink" title="LeeteCode 560. Subarray Sum Equals K"></a>LeeteCode 560. <a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a></h1><p>计算出从第一个数到每一个数的和，那么任意一段连续数字的和就可以通过两段和相减得出。<br>用sum表示从数组起始位置到当前位置所有数字的加和，用<code>Hash Table</code>来存储sum出现的次数，如果当前位置之前有和（prefix sum）为<code>sum - k</code>的位置，则这两个位置之间的数字之和为k。那么，以当前位置结尾，和为k的子数组个数为<code>hash[sum - k]</code>。遍历整个数组即可得出满足条件的子数组个数。<br><img src="//zhhp1001.github.io/2019/06/05/Hash/leet560.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashNums;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    hashNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">if</span> (hashNums.count(sum - k))   <span class="comment">//这个if()可以提高近一半的效率</span></span><br><span class="line">            result += hashNums[sum - k];</span><br><span class="line">        hashNums[sum]++;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下图所示，<code>if(hashNums.count(sum - k))</code> 对效率的提升是很惊人的<br><img src="//zhhp1001.github.io/2019/06/05/Hash/run.png" alt></p><p>LeetCode <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49.Group Anagrams</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mapStr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = str;</span><br><span class="line">            sort(temp.begin(), temp.end());</span><br><span class="line">            mapStr[temp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : mapStr) &#123;</span><br><span class="line">            result.push_back(str.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一个for循环处"><a href="#第一个for循环处" class="headerlink" title="第一个for循环处"></a>第一个for循环处</h2><p>能自己写出类型来就不要用auto了</p><h2 id="unordered-map-第二个类型为vector容器时的情况"><a href="#unordered-map-第二个类型为vector容器时的情况" class="headerlink" title="unordered_map 第二个类型为vector容器时的情况"></a>unordered_map 第二个类型为vector容器时的情况</h2><h2 id="使用stl的-sort函数"><a href="#使用stl的-sort函数" class="headerlink" title="使用stl的 sort函数"></a>使用stl的 sort函数</h2><p>头文件<algorithm></algorithm></p><p>语法描述 sort(begin, end, cmp)  cmp参数可以没有， 默认为非降序排序。<br><strong>cmp:</strong></p><ul><li>升序： <code>less&lt;data-type&gt;</code></li><li>降序： <code>greater&lt;data-type&gt;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">sort(a, a + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构与算法-unordered_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历（C++实现）</title>
      <link href="/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义二叉树结点类"><a href="#定义二叉树结点类" class="headerlink" title="定义二叉树结点类"></a>定义二叉树结点类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BnaryTreeNode* lc;</span><br><span class="line">    BinaryTreeNode* rc;</span><br><span class="line">    BinaryTreeNode (<span class="keyword">int</span> cont&amp; _val, BinaryTreeNode* _lc = <span class="literal">nullptr</span>, BinaryTreeNode* _rc = <span class="literal">nullptr</span>) : </span><br><span class="line">    val(_val), lc(_lc), rc(_rc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先序遍历、中序遍历、后序遍历<strong>访问节点</strong>的顺序是一致的， 不同之处在于处理节点的顺序。有的遍历流程把访问到的节点暂存起来，达成某种条件后再对其进行处理（比如输出），我们约定，根节点V、左孩子L、右孩子R，那么遍历顺序可以记为：</p><ul><li>先序遍历VLR：到达一个节点后，即刻输出该节点的值，并继续遍历其左、右子树。</li><li>中序遍历LVR：到达一个节点后，先将该节点暂存，遍历完其左子树后，再输出该节点的值，然后遍历其右子树。</li><li>后序遍历LRV： 到达一个节点后，先将该节点暂存，遍历完其左右子树后，再输出该节点的值。</li></ul><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="先序遍历（VLR）"><a href="#先序遍历（VLR）" class="headerlink" title="先序遍历（VLR）"></a>先序遍历（VLR）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>与先序遍历类似，唯一区别是到达该节点时，并不直接输出该节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已遍历完成。 因此， 我们需要设置一个<strong>lastvisit指针</strong>，若lastvisit指向当前节点的右孩子，表示该节点的左右子树都已遍历完成，可以输出当前节点 （否则，继续探索当前节点的右子树）， 并使lastvisit指向当前节点， 将当前节点（指针）设置为空（这样，下一轮循环就可以访问栈顶元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    BinaryTreeNode* lastvisit = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;rc == <span class="literal">nullptr</span> || root-&gt;rc == lastvisit) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                lastvisit = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
