<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面试总结</title>
      <link href="/2019/07/31/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/31/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/u012414189/article/details/83856874" target="_blank" rel="noopener">https://blog.csdn.net/u012414189/article/details/83856874</a></p><h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1-指针和引用的区别"><a href="#1-指针和引用的区别" class="headerlink" title="1. 指针和引用的区别"></a>1. 指针和引用的区别</h2><p>C++之父：我为啥引入引用<br><img src="//zhhp1001.github.io/2019/07/31/面试总结/1.png" alt></p><p>“引用是别名”这个概念仅仅只是在语言级别上，深入底层的话，引用必定需要存储绑定的对象的地址信息的，所以肯定会占内存。 （引用只是一个概念，怎么实现，由编译器决定，一般实现为const指针）</p><ul><li>引用并非对象，它只是为一个已经存在的对象所起的别名。 指针本身就是一个对象。</li><li>因此不能定义引用的引用（多级引用）， 但是可以使用多级指针（int** p）。</li><li>reference必须绑定某个对象，没有所谓null reference，因此必须在定义时赋初值。 指针可以为空，无须在定义时赋初值（在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值）。</li><li>sizeof引用 得到的是所绑定对象的大小， sizeof指针 得到的是计算机的字长（word size ， 32位/64位， 4字节/8字节）</li></ul><h2 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a>2. 堆和栈的区别</h2><p>1.申请方式： 堆是程序员申请，栈是系统自动分配<br>2.系统响应： 栈： 只要栈的剩余空间大于所申请的空间，系统就会为程序提供内存，否则栈溢出；<br>            堆： 堆分配算法。。。<br>3.空间大小： 堆是不连续的区域，空间很大，上限取决于有效的虚拟内存； 栈是一块连续的区域，大小一般是1-2M<br>4.生长方向： 堆向上生长， 栈向下生长（高地址向低地址）<br>5.分配方式： 堆是动态分配的。<br>6.分配效率： 栈是系统底层数据结构，效率比较高，堆是C++函数库提供的，效率低<br>7.碎片问题： 栈内存是连续的，而堆在多次new和delete后会产生很多碎片</p><h2 id="3-new和delete是如何实现的，new-与-malloc的异同处"><a href="#3-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="3. new和delete是如何实现的，new 与 malloc的异同处"></a>3. new和delete是如何实现的，new 与 malloc的异同处</h2><ol start="0"><li>属性</li></ol><p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p><ol><li>参数</li></ol><p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p><ol start="2"><li>返回类型</li></ol><p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p><ol start="3"><li>分配失败</li></ol><p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p><ol start="4"><li><p>自定义类型</p><p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p><p> malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p></li><li><p>重载</p></li></ol><p>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p><ol start="6"><li>内存区域</li></ol><p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p><p>malloc/free与new/delete异同点</p><p>相同点<br>malloc/free与new/delete都可以用于申请动态内存和释放内存，他们申请的空间都在堆上分配。</p><p>不同点<br>1）操作对象不同<br>malloc/free是C++/C语言的标准库文件，new/delete是C++的运算符；<br>对非内部数据对象，malloc/free无法满足动态对象要求。对象在创建时要自动执行构造函数，对象消亡之前要自动执行析构函数，而malloc/free是库函数，不是运算符，故不在编译器控制权限之内，不能够将执行构造函数和析构函数强加于malloc/free身上。而由于new/delete是C++语言，能够完成动态内存分配和初始化工作，并能够完成清理与释放内存工作，即能够自动执行构造函数和析构函数；</p><p>2）用法不同<br>malloc分配内存空间前需要计算分配内存大小；而new能够自动分配内存空间；<br>malloc是底层函数，其函数返回值类型为void *；而new运算符调用无参构造函数，故返回值为对应对象的指针；<br>malloc函数类型不是安全的，编译器不对其进行类型转换、类型安全的相关检查。malloc申请空间后，不会对其初始化，要单独初始化；而new类型是安全的，因为它内置了sizeof、类型转换和类型安全检查功能，且在创建对象时，就完成了初始化工作，一般初始化调用无参构造函数；</p><p>operator new对应于malloc，且operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上；但malloc不能。</p><p>free只进行释放空间；而delete则释放空间的同时调用析构函数。<br>此外delete使用是注意释放数组的方法为delete []数组名。</p><p>联系</p><h2 id="new和delete功能覆盖了malloc-free，但因C-程序常会用到C函数，而C函数只能使用malloc-free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。"><a href="#new和delete功能覆盖了malloc-free，但因C-程序常会用到C函数，而C函数只能使用malloc-free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。" class="headerlink" title="new和delete功能覆盖了malloc/free，但因C++程序常会用到C函数，而C函数只能使用malloc/free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。"></a>new和delete功能覆盖了malloc/free，但因C++程序常会用到C函数，而C函数只能使用malloc/free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。</h2><p>作者：祚儿疯<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/u012414189/article/details/83856874" target="_blank" rel="noopener">https://blog.csdn.net/u012414189/article/details/83856874</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p><h2 id="4-C和C-的区别"><a href="#4-C和C-的区别" class="headerlink" title="4. C和C++的区别"></a>4. C和C++的区别</h2><p>C 是面向过程的一门编程语言，C++ 可以很好地进行面向对象的程序设计。C++ 虽然主要是以 C 的基础发展起来的一门新语言，但它不是 C 的替代品，它们是兄弟关系。面向对象和面向过程不是矛盾的，而是各有用途、互为补充的。<br>C++ 对 C 的增强，表现在六个方面：</p><ul><li>增强了类型检查机制</li><li>增加了面向对象的机制</li><li>增加了泛型编程的机制（template）</li><li>增加了异常处理</li><li>增加了重载的机制</li><li>增加了标准模板库（STL）<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3>C/C++ 是静态数据类型语言，类型检查发生在编译时，因此编译器知道程序中每一个变量对应的数据类型。C++ 的类型检查相对更严格一些。<br>很多时候需要一种能够实际表示多种类型的数据类型。传统上 C 使用 void* 指针指向不同对象，使用时强制转换回原始类型或兼容类型。这样做的缺陷是绕过了编译器的类型检查，如果错误转换了类型并使用，会造成程序崩溃等严重问题。<br>C++ 通过使用基类指针或引用来代替 void* 的使用，避免了这个问题（其实也是体现了类继承的多态性）。<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3>C 的结构体传递的是一种数据结构，我们只是在主函数里面对这种数据类型做某种调用。主函数的架构依然是基于函数、函数族的处理过程，即面向过程。<br>C++ 中最大的区别就是允许在结构体中封装函数，而在其他的地方直接调用这个函数。这个封装好的可直接调用的模块有个新名词——对象；并且也把结构体换一个名字——类。这就是面向对象的思想。在构建对象的时候，把对象的一些操作全部定义好并且给出接口的方式，对于外部使用者而言，可以不需要知道函数的处理过程，只需要知道调用方式、传递参数、返回值、处理结果。<h3 id="泛型编程（template）"><a href="#泛型编程（template）" class="headerlink" title="泛型编程（template）"></a>泛型编程（template）</h3>所谓泛型编程，简而言之就是不同的类型采用相同的方式来操作。在 C++ 的使用过程中，直接 template 用的不多，但是用 template 写的库是不可能不用的。因此需要对泛型有比较深入的了解，才可以更好地使用这些库。<br>C++ 里面的模版技术具有比类、函数更高的抽象水平，因为模版能够生成出（实例化）类和函数。可以用来：<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3>C 语言不提供对错误处理的直接支持，但它以返回值的形式允许程序员访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。可以在 errno.h 头文件中找到各种各样的错误代码。<br>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0（表示没有错误），这是一种良好的编程习惯。<br>C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。<h3 id="函数重载-amp-运算符重载"><a href="#函数重载-amp-运算符重载" class="headerlink" title="函数重载 &amp; 运算符重载"></a>函数重载 &amp; 运算符重载</h3>C++ 可以实现函数重载，条件是：函数名必须相同，返回值类型也必须相同，但参数的个数、类型或顺序至少有其一不同。<br>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。大多数的重载运算符可被定义为普通的非成员函数（func(a, b) 形式调用）或者被定义为类成员函数（a.func(b) 形式调用）。<h3 id="标准模板库（STL）"><a href="#标准模板库（STL）" class="headerlink" title="标准模板库（STL）"></a>标准模板库（STL）</h3></exception></li></ul><h2 id="5-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#5-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="5. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>5. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h2><p>两者都是面向对象的语言，两者都能实现面向对象的核心思想（封装、继承、多态）。但是由于c++为了兼容c语言，java不兼容C，它是一种完全的面向对象语言。</p><p>区别：<br>语言特性：<br>1.指针：c++有指针来访问内存，而JAVA中对于用户态，编程者无法找到指针来直接访问内存指针，只有限定版的引用，更加安全。<br>2.多重继承：c++支持多重继承，可以继承多个父类。JAVA不支持多重继承，但是允许一个类继承多个接口。<br>3.数据类型和类：Java是完全面向对象的语言，所有函数和变量都必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而c++允许将函数和变量定义为全局的。<br>4.自动内存管理：java内存支持自动对无用内存回收管理，c++需要人为的使用delete去释放内存。<br>5.c++支持操作符重载，但是java不支持操作符重载</p><p>垃圾回收：<br>java内存支持自动对无用内存回收管理，c++需要人为的使用delete去释放内存。</p><p>应用场景：<br>C++相对于java来看是偏底层的语言，应用场景也是一些偏底层的软件，例如：图像，客户端，桌面软件等。<br>JAVA则是偏向应用的语言，相对来说，生态圈较好，有一些高级特性也比较好用，一般是上层应用软件，例如移动设备的软件，web网页后台逻辑开发等等。</p><h2 id="6-Struct和class的区别"><a href="#6-Struct和class的区别" class="headerlink" title="6. Struct和class的区别"></a>6. Struct和class的区别</h2><p>C++中class和struct的<strong>访问控制权限</strong>不同，class默认private struct默认为public<br>继承：class继承默认是private继承，而struct继承默认是public继承</p><h2 id="7-define-和const的区别（编译阶段、安全性、内存占用等）"><a href="#7-define-和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="7. define 和const的区别（编译阶段、安全性、内存占用等）"></a>7. define 和const的区别（编译阶段、安全性、内存占用等）</h2><p>编译阶段： define是预编译阶段展开，而const是在运行阶段使用<br>安全性： const常量是有数据类型的，那么编译器会对const变量的类型等安全性进行检查，但是define只是在预编译阶段展开，不会进行类型的安全检查，替换时可能产生错误。<br>内存占用： define不会占用内存，单纯的替换而已， const会占用内存，会有对应的内存地址。</p><h2 id="8-在C-中const和static的用法（定义，用途）"><a href="#8-在C-中const和static的用法（定义，用途）" class="headerlink" title="8. 在C++中const和static的用法（定义，用途）"></a>8. 在C++中const和static的用法（定义，用途）</h2><p>const成员也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。<br>const数据成员只在某个对象的生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。<br>const数据成员的初始化只能在构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者’static const’</p><p>static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。</p><p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。如：double Account::Rate = 2.5; static 关键字只能用于类定义体内部的声明中，定义时不能表示为static。<br>用途：<br>const成员函数主要目的是防止成员函数修改对象的内容，即const成员函数不能修改成员变量的值，但可以访问成员变量。<br>static成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1.不能直接存取类的非静态成员变量，调用非静态成员函数2.不能被声明为virtual。</p><h2 id="9-const和static在类中使用的注意事项（定义、初始化和使用）"><a href="#9-const和static在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="9. const和static在类中使用的注意事项（定义、初始化和使用）"></a>9. const和static在类中使用的注意事项（定义、初始化和使用）</h2><p>定义： const可以在类内部定义，但是定义的位置不能初始化；static只能在类的内部声明，定义只能在类的外部，并且定义的时候不能加static关键字。<br>初始化： const只能在类的构造函数的初始化列表中初始化；static初始化不能在类内部初始化，必须在类外部初始化。<br>用途：<br>const成员函数主要目的是防止成员函数修改对象的内容，即const成员函数不能修改成员变量的值，但可以访问成员变量。<br>static成员函数主要目的是作为<strong>类作用域的全局函数</strong>。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1.不能直接存取类的非静态成员变量，调用非静态成员函数2.不能被声明为virtual。</p><h2 id="10-C-中的const类成员函数（用法和意义）"><a href="#10-C-中的const类成员函数（用法和意义）" class="headerlink" title="10. C++中的const类成员函数（用法和意义）"></a>10. C++中的const类成员函数（用法和意义）</h2><ol><li><code>void func() const;</code><br>表明是常量成员函数，这个const表明这个函数不会改变数据成员的值。</li><li><code>void func(const a) const;</code><br>表明是参数是常量的常量成员函数，接收的参数是常量，同时不能修改数据成员的值。</li></ol><p>意义： 为什么这么做？<br>这是为了保证它能被const常量对象调用，我们知道，在定义一个对象或者一个变量时，如果在类型前加一个const,如const int x；则表示定义了一个常量，它的值不能被修改。但是创建的对象却可以调用成员函数，调用的成员函数很可能改变对象的值。所以这个时候const类成员函数就出现了。<br>我们把那些肯定不会修改对象的各个属性值的成员函数加上const说明符，这样，在编译时，编译器将对这些const成员函数进行检查，如果确实没有修改对象值的行为，则检查通过，之后，如果一个const常对象调用这些const成员函数，编译器将允许。</p><h2 id="11-计算下面几个类的大小："><a href="#11-计算下面几个类的大小：" class="headerlink" title="11.  计算下面几个类的大小："></a>11.  计算下面几个类的大小：</h2><p>class A {};: sizeof(A) = 1;<br>class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);<br>class A { static int a; };: sizeof(A) = 1;<br>class A { int a; };: sizeof(A) = 4;<br>class A { static int a; int b; };: sizeof(A) = 4;<br>1.确切地说，类只是一个类型定义，它是没有大小可言的。用sizeof运算符对一个类型名操作，得到的是具有该类型 实体的大小。<br>2.一个对象的大小等于所有<strong>非静态成员</strong>大小的总和，大于的部分是编译器自主添加的。<br>C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1.如果在类中声明了虚函数（不管是一个还是多个），在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表。而虚函数本身和其他成员函数一样，不占用对象的空间。</p><h2 id="12-给一个代码，求输出结果"><a href="#12-给一个代码，求输出结果" class="headerlink" title="12. 给一个代码，求输出结果"></a>12. 给一个代码，求输出结果</h2><p>class A<br>{public:<br>A(int x){}<br>}问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？<br>这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，栗子很多，不多说了）</p><p>正确。 由于A没有显示的声明，所以可以用int型进行强制转换，编译器碰到这种情况，首先如果是没有优化的编译器，对1进行强制转换int型，然后调用默认的赋值函数，1赋值给x，然后调用构造函数构造。其次，如果是有优化的编译器，可以将1强制转换成A类型，调用一次构造函数，然后再调用默认赋值构造函数赋值给a。</p><h2 id="13-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#13-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="13.  C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>13.  C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h2><p>STL是一个c++里面非常强大的库，c11引进的，里面封装例如容器，泛型算法等。</p><h2 id="14-STL源码中的hash表的实现"><a href="#14-STL源码中的hash表的实现" class="headerlink" title="14.  STL源码中的hash表的实现"></a>14.  STL源码中的hash表的实现</h2><p>hash_table是STL中hash_map 和 hash_set 的内部数据结构，hash_table的插入/删除/查找的时间复杂度都为O(1),是查找速度最快的一种数据结构，但是hash_table中的数据是无序的，一般也只有在数据不需要排序，只需要满足快速查找/插入/删除的时候使用hash_table。</p><h2 id="15-STL中unordered-map和map的区别"><a href="#15-STL中unordered-map和map的区别" class="headerlink" title="15. STL中unordered_map和map的区别"></a>15. STL中unordered_map和map的区别</h2><p>map是一种映射，这种映射是有序的，底层是使用红黑树来完成的，数据通过键值才存储，键是唯一的。<br>unordered_map，是一种无序的，底层是通过hash表来完成的。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。每个桶都是用list来完成的。<br>map<br>优点： </p><ul><li>有序性： 其元素的有序性再很多应用中都会简化很多操作。</li><li>红黑树： 内部实现一个红黑树使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率很高。<br>缺点：</li><li>空间占用率高，每一个节点都需要额外保存父节点，孩子节点以及红黑性质，使得每一个节点都会占用大量的空间。<br>适用于： 对顺序有要求的问题。<br>unordered_map<br>优点： 由于使用了哈希表，因此查找速度非常快。<br>缺点： 哈希表的建立比较耗费时间<br>适用于： 查找问题<h2 id="16-STL中vector的实现"><a href="#16-STL中vector的实现" class="headerlink" title="16. STL中vector的实现"></a>16. STL中vector的实现</h2>注意两个点：</li></ul><p>1.vector有备用空间，当备用空间不够的时候，会重新开辟原空间两倍的空间进行重写分配。<br>2.vector支持随机的存取，但是最好是选择从末尾插入，因为从中间插入会导致元素的移动，带来了性能的开销。</p><h2 id="17-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#17-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="17. vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>17. vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h2><p>vector压入容器的对象都是拷贝操作，而且vector的数据存放都是连续存储的，所以在操作vector操作时，应该尽量避免对尾部操作之后的地方插入删除操作，因为这样会造成元素的移动，造成大量的开销。</p><p>频繁对vector调用push_back()会导致性能下降，这是由于系统每次给vector分配固定大小的空间，这个空间可能比用户想分配的空间大一些，但是频繁的使用push_back向容器中插入元素，会导致内存分配空间不够，会再次将整个对象的存储空间重新分配，将旧的元素移动到新的空间中，开销是非常大的。</p><h2 id="18-C-中的重载和重写的区别"><a href="#18-C-中的重载和重写的区别" class="headerlink" title="18. C++中的重载和重写的区别"></a>18. C++中的重载和重写的区别</h2><p><a href="https://blog.csdn.net/xu1105775448/article/details/80118159" target="_blank" rel="noopener">https://blog.csdn.net/xu1105775448/article/details/80118159</a><br>重载：</p><p>1.在同一个作用域下，函数名相同，函数的参数不同（参数不同指参数的类型或参数的个数不相同）<br>2.不能根据返回值判断两个函数是否构成重载。<br>3.当函数构成重载后，调用该函数时，编译器会根据函数的参数选择合适的函数进行调用。</p><p>重定义（隐藏）<br>1.在不同的作用域下（这里不同的作用域指一个在子类，一个在父类 ），函数名相同的两个函数构成重定义。<br>2.当两个函数构成重定义时，父类的同名函数会被隐藏，当用子类的对象调用同名的函数时，如果不指定类作用符，就只会调用子类的同名函数。<br>3.如果想要调用父类的同名函数，就必须指定父类的域作用符。</p><p>重写<br>也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。</p><h2 id="19-C-内存管理（热门问题）"><a href="#19-C-内存管理（热门问题）" class="headerlink" title="19. C ++内存管理（热门问题）"></a>19. C ++内存管理（热门问题）</h2><p>c++的内存管理延续c语言的内存管理，但是也增加了其他的，例如智能指针，除了常见的堆栈的内存管理之外，c++支持智能指针，智能指针的对象进行赋值拷贝等操作的时候，每个智能指针都有一个关联的计数器，该计数器记录共享该对象的指针个数，当最后一个指针被销毁的时候，计数器为0,会自动调用析构函数来销毁函数。</p><h2 id="20-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#20-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="20. 介绍面向对象的三大特性，并且举例说明每一个。"></a>20. 介绍面向对象的三大特性，并且举例说明每一个。</h2><p>面向对象的三大特性：封装、继承、多态。</p><p>封装：将很多有相似特性的内容封装在一个类中，例如学生的成绩学号、课程这些可以封装在同一个类中；</p><p>继承：某些相似的特性，可以从一个类继承到另一个类，类似生活中的继承，例如有个所有的汽车都有4个轮子，那么我们在父类中定义4个轮子，通过继承获得4个轮子的功能，不用再类里面再去定义这4个轮子的功能。</p><p>多态：多态指的相同的功能，不同的状态，多态在面向对象c++里面是通过重载和覆盖来完成的，覆盖在c++里面通过虚函数来完成的。例如鸭子的例子，所有的鸭子都有颜色，我们可以将这个颜色设置成为一个虚函数，通过继承子类对虚函数进行覆盖，不同子类中有各自的颜色，也就是有各自不同的鸭子颜色，这就是多态的典型表现之一。</p><h2 id="21-多态的实现（和下个问题一起回答）"><a href="#21-多态的实现（和下个问题一起回答）" class="headerlink" title="21. 多态的实现（和下个问题一起回答）"></a>21. 多态的实现（和下个问题一起回答）</h2><h2 id="22-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#22-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="22. C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>22. C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h2><p>多态通过覆盖和重载来完成。</p><p>虚函数分为两种，纯虚函数和虚函数，纯虚函数适用于抽象基类，不需要定义，类似一种接口，是多态的典型处理方式。</p><p>一个类如果定义了虚函数，那么编译器会自动为它加上一个虚函数表，并提供一个指向虚函数表的指针，子类通过继承，可以覆盖父类的虚函数，当用户调用虚函数的时候，会调用指针，去虚函数表中找匹配的虚函数，如果当前对象有覆盖的虚函数，则去执行覆盖的虚函数，否则执行父类的虚函数。</p><h2 id="23-实现编译器处理虚函数表应该如何处理"><a href="#23-实现编译器处理虚函数表应该如何处理" class="headerlink" title="23. 实现编译器处理虚函数表应该如何处理"></a>23. 实现编译器处理虚函数表应该如何处理</h2><p>虚函数表的主要目的是提供一张表，表上记录子类父类的虚函数地址，通过虚函数表可以达到动态绑定的目的。</p><p>编译器首先在编译阶段完成虚函数表的建立，然后当给父类的指针初始化指向的是哪个子类，编译器按照绑定的子类去虚函数表中找对应子类的虚函数，并绑定，这样达到了动态绑定的目的，主要这个绑定是发生在运行的阶段。</p><h2 id="24-析构函数一般写成虚函数的原因"><a href="#24-析构函数一般写成虚函数的原因" class="headerlink" title="24. 析构函数一般写成虚函数的原因"></a>24. 析构函数一般写成虚函数的原因</h2><p>因为在继承中，我们最后要销毁对象的时候，会调用析构函数，这个时候我们希望析构的是子类的对象，那么我们需要调用子类的析构函数，但是这个时候指针又是父类的指针，所以这个时候我们也要对析构函数写成虚构函数，这样析构函数的虚属性也会被继承，那么无论我们什么时候析构，都能动态绑定到我们需要析构的对象上。</p><h2 id="25-构造函数为什么一般不定义为虚函数"><a href="#25-构造函数为什么一般不定义为虚函数" class="headerlink" title="25. 构造函数为什么一般不定义为虚函数"></a>25. 构造函数为什么一般不定义为虚函数</h2><p>三个原因：<br>1.虚函数的作用是什么？是实现部分或默认的功能，而且该功能可以被子类所修改。如果父类的构造函数设置成虚函数，那么子类的构造函数会直接覆盖掉父类的构造函数。而父类的构造函数就失去了一些初始化的功能。这与子类的构造需要先完成父类的构造的流程相违背了。而这个后果会相当严重。</p><p>2.虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则。</p><p>3.虚函数的调用是由父类指针进行完成的，而对象的构造则是由编译器完成的，由于在创建一个对象的过程中，涉及到资源的创建，类型的确定，而这些是无法在运行过程中确定的，需要在编译的过程中就确定下来。而多态是在运行过程中体现出来的，所以是不能够通过虚函数来创建构造函数的，与实例化的次序不同也有关系。</p><p>那么虚够函数为什么可以设计成虚函数呢？由于虚函数是释放对象的时候才执行的，所以一开始也就无法确定析够函数的。而去由于析构的过程中，是先析构子类对象，后析构父类对象。所以，需要通过虚函数来指引子类对象。所以，如果不设置成虚函数的话，析构函数是无法执行子类的析构函数的。</p><h2 id="26-构造函数或者析构函数中调用虚函数会怎样"><a href="#26-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="26. 构造函数或者析构函数中调用虚函数会怎样"></a>26. 构造函数或者析构函数中调用虚函数会怎样</h2><p>为什么呢？这是由于构造函数或者析构函数中调用虚函数这个时候，子类或许出于一个未初始化的状态，因为c++中父类先构造然后是子类，那么父类中构造调用子类，都没有构造，调用子类的虚函数，显然是错误的。</p><h2 id="27-纯虚函数"><a href="#27-纯虚函数" class="headerlink" title="27. 纯虚函数"></a>27. 纯虚函数</h2><p>纯虚函数不需要定义，我们不能够为纯虚函数提供函数体，同样的，包含纯虚函数的基类是抽象基类，抽象基类是不能创建对象的，只能通过继承，继承子类中覆盖纯虚函数，执行自己的功能，子类是可以创建对象的。</p><h2 id="28-静态绑定和动态绑定的介绍"><a href="#28-静态绑定和动态绑定的介绍" class="headerlink" title="28. 静态绑定和动态绑定的介绍"></a>28. 静态绑定和动态绑定的介绍</h2><p>静态绑定：通过用户定义指针指向的类型来进行绑定，在编译的时候已经完成。</p><p>动态邦定：c++中虚函数的功能，通过虚函数表，在运行阶段进行绑定，即运行的时候才知道绑定的函数。</p><h2 id="29-引用是否能实现动态绑定，为什么引用可以实现"><a href="#29-引用是否能实现动态绑定，为什么引用可以实现" class="headerlink" title="29. 引用是否能实现动态绑定，为什么引用可以实现"></a>29. 引用是否能实现动态绑定，为什么引用可以实现</h2><p>可以实现，因为动态绑定是发生在程序运行阶段的，c++中动态绑定是通过对基类的引用或者指针调用虚函数时发生。<br>因为引用或者指针的对象是可以在编译的时候不确定的，如果是直接传对象的话，在程序编译的阶段就会完成，对于引用，其实就是地址，在编译的时候可以不绑定对象，在实际运行的时候，在通过虚函数绑定对象即可。</p><h2 id="30-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#30-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="30. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>30. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><p>深拷贝就是拷贝内容，浅拷贝就是拷贝指针。<br>浅拷贝拷贝指针，也就是说同一个对象，拷贝了两个指针，指向了同一个对象，那么当销毁的时候，可能两个指针销毁，就会导致内存泄漏的问题。<br>深拷贝不存在这个问题，因为是首先申请和拷贝数据一样大的内存空间，把数据复制过去。这样拷贝多少次，就有多少个不同的内存空间，干扰不到对方。</p><h2 id="31-对象复用的了解，零拷贝的了解"><a href="#31-对象复用的了解，零拷贝的了解" class="headerlink" title="31. 对象复用的了解，零拷贝的了解"></a>31. 对象复用的了解，零拷贝的了解</h2><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p><h2 id="32-介绍C-所有的构造函数"><a href="#32-介绍C-所有的构造函数" class="headerlink" title="32.  介绍C++所有的构造函数"></a>32.  介绍C++所有的构造函数</h2><p>默认构造函数、一般构造函数、拷贝构造函数<br>默认构造函数（无参数）：如果创建一个类你没有写任何构造函数,则系统会自动生成默认的构造函数，或者写了一个不带任何形参的构造函数。<br>一般构造函数：一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）。<br>拷贝构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。参数（对象的引用）是不可变的（const类型）。此函数经常用在函数调用时用户定义类型的值传递及返回。</p><h2 id="33-什么情况下会调用拷贝构造函数（三种情况）"><a href="#33-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="33. 什么情况下会调用拷贝构造函数（三种情况）"></a>33. 什么情况下会调用拷贝构造函数（三种情况）</h2><p>（1）用类的一个对象去初始化另一个对象时<br>（2）当函数的形参是类的对象时（也就是值传递时），如果是<strong>引用传递则不会调用</strong><br>（3）当函数的返回值是类的对象或引用时</p><h2 id="34-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#34-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="34. 结构体内存对齐方式和为什么要进行内存对齐？"></a>34. 结构体内存对齐方式和为什么要进行内存对齐？</h2><p>1.前面的地址必须是后面的地址正数倍,不是就补齐<br>2.整个Struct的地址必须是最大字节的整数倍<br>为什么要？<br>空间换时间，加快cpu访问内存的效率，这是因为许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p><h2 id="35-内存泄露的定义，如何检测与避免？"><a href="#35-内存泄露的定义，如何检测与避免？" class="headerlink" title="35. 内存泄露的定义，如何检测与避免？"></a>35. 内存泄露的定义，如何检测与避免？</h2><p>内存泄漏指的是开辟的内存没有释放，或者是存在用户操作的错误，导致野指针，无法释放原来分配的内存。</p><p>工具监测：在vs里面支持CRT这个库函数，函数里面有内存监测工具，可以调用，在程序中判断内存时否有泄漏。</p><p>人为监测：观测所有new开辟内存空间的地方有没有free掉。</p><p>避免：在编程习惯上要注意使用尽量使用STL函数，使用vector而不是数组，使用智能指针而不是指针。</p><h2 id="36-手写实现智能指针类（34-37我没遇见过）"><a href="#36-手写实现智能指针类（34-37我没遇见过）" class="headerlink" title="36. 手写实现智能指针类（34-37我没遇见过）"></a>36. 手写实现智能指针类（34-37我没遇见过）</h2><h2 id="37-调试程序的方法"><a href="#37-调试程序的方法" class="headerlink" title="37. 调试程序的方法"></a>37. 调试程序的方法</h2><p>这个方式很多，裸机程序，主动调试，gdb调试，IDE断点调试等。</p><h2 id="38-遇到coredump要怎么调试"><a href="#38-遇到coredump要怎么调试" class="headerlink" title="38. 遇到coredump要怎么调试"></a>38. 遇到coredump要怎么调试</h2><p>内存泄漏的方法很多，可以用gdb打开core文件，确定出错的堆栈地点，从而判断程序出错的位置。</p><h2 id="39-内存检查工具的了解"><a href="#39-内存检查工具的了解" class="headerlink" title="39. 内存检查工具的了解"></a>39. 内存检查工具的了解</h2><p>在vs里面支持CRT这个库函数</p><h2 id="40-模板的用法与适用场景"><a href="#40-模板的用法与适用场景" class="headerlink" title="40. 模板的用法与适用场景"></a>40. 模板的用法与适用场景</h2><p>模板是C11里面添加的，使用与在不知道类型的情况下，编写一个泛型的程序，模板通过用一个指定的关键字来代替类型，进行泛型编程。</p><p>应用场景：应用场景很多，例如我们要编程一些和类型无关的代码时，STL里面的很多容器都是用到了模板，容器的功能都可以使用，但并没有确定容器里面一定要用指定的类型，可以是任何的类型。</p><h2 id="41-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#41-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="41. 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>41. 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h2><p>成员初始化的概念，就是说类的成员使用在定义的时候就使用构造函数初始值列表初始化</p><p>使用成员初始化要快些，这里说的快些是比较的是赋值，如果指定义变量，没有列表初始化，那么这样变量旧会执行默认的初始化，然后在赋值，这样就多了一次赋值操作，带来的开销取决于数据成员的类型。</p><p>除了效率之外，有一些成员必须列表初始化，例如<strong>**const</strong>或者<strong>**</strong>引用**</p><h2 id="42-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#42-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="42. 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>42. 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h2><p>例如：auto、decltype,nullptr,for(auto i:m),lambda表达式，智能指针等。</p><h2 id="43-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#43-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="43. C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>43. C++的调用惯例（简单一点C++函数调用的压栈过程）</h2><p>对于程序，编译器会对其分配一段内存，在逻辑上可以分为代码段，数据段，堆，栈<br>代码段：保存程序文本，指令指针EIP就是指向代码段，可读可执行不可写<br>数据段：保存初始化的全局变量和静态变量，可读可写不可执行<br>BSS：未初始化的全局变量和静态变量<br>堆(Heap)：动态分配内存，向地址增大的方向增长，可读可写可执行<br>栈(Stack)：存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，非常非常重要，可读可写可执行</p><p>程序开始，从main开始，首先将参数压入栈，然后压入函数返回地址，进行函数调用，通过跳转指定进入函数，将函数内部的变量去堆栈上开辟空间，执行函数功能，执行完成，取回函数返回地址，进行下一个函数。</p><h2 id="44-C-的四种强制转换"><a href="#44-C-的四种强制转换" class="headerlink" title="44.  C++的四种强制转换"></a>44.  C++的四种强制转换</h2><p>四种强制转换是static_cast、dynamic_cast、const_cast、reinterpret_cast。</p><p>static_cast：静态强制转换，类似传统c语言里面括号的强制转换<br>dynamic_cast：动态强制转换，主要应用于多态，父子类的类型转换，dynamic_cast和static_cast不同的是，它会检查类型转换是否正确，不能转换，则会返回null，所以不算是强制转换。<br>const_cast：取出const属性，比较简单，可以把const类型转换为非conse指针类型。<br>reinterpret_cast：一种非常随意的二进制转换，简单理解对一个二进制序列的重新解释。</p><h2 id="45-阅读C-语言代码输出（）"><a href="#45-阅读C-语言代码输出（）" class="headerlink" title="45.阅读C++语言代码输出（）"></a>45.阅读C++语言代码输出（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出 3 3<br>第4行： <em>p=arr[0]<br>第5行：arr[0]=90;p自加1，此时</em>p=arr[1];<br>第6行：先计算<em>(++p),</em>p=arr[2],在计算*p=arr[2].原因prinf从右到左编译，从左到右输出<br>试了一下，cout也是如此<br>从右向左压值，从左向右调用。<br>cout &lt;&lt; a &lt;&lt; b;<br>相当于cout.operator &lt;&lt;(a).operator &lt;&lt;(b);</p><h2 id="46-阅读c-代码输出（）"><a href="#46-阅读c-代码输出（）" class="headerlink" title="46. 阅读c++代码输出（）"></a>46. 阅读c++代码输出（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>: <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    base1 ( <span class="keyword">int</span> i ) : b(i+<span class="number">1</span>),a(b)&#123;&#125;</span><br><span class="line">    base1():b(<span class="number">0</span>),a(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">base1 <span class="title">obj1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj1.get_a()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;obj1.get_b()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出： 随机数 12</p><p>初始化列表的执行顺序是变量的声明顺序</p><h2 id="47-64位电脑-运行c-结果输出（）"><a href="#47-64位电脑-运行c-结果输出（）" class="headerlink" title="47. 64位电脑 运行c++结果输出（）"></a>47. 64位电脑 运行c++结果输出（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(C);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="48-下列选项中，不可能是快速排序第2趟排序结果的是-（）"><a href="#48-下列选项中，不可能是快速排序第2趟排序结果的是-（）" class="headerlink" title="48. 下列选项中，不可能是快速排序第2趟排序结果的是 （）"></a>48. 下列选项中，不可能是快速排序第2趟排序结果的是 （）</h2><p>4 14 10 12 8 6 18<br>4 6 10 8 12 14 18<br>6 4 10 8 14 12 18<br>6 4 10 8 14 12 18</p><p>快速排序的核心思想是基准数就位，每一趟至少有一个基准数就位，所以两趟下来至少就位两个基准数就位，C选项只有18就位，所以错误</p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断是否为BST</title>
      <link href="/2019/07/12/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BABST/"/>
      <url>/2019/07/12/%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BABST/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-Validate-Binary-Search-Tree"><a href="#LeetCode-Validate-Binary-Search-Tree" class="headerlink" title="LeetCode Validate Binary Search Tree"></a>LeetCode <a href="https://leetcode.com/explore/learn/card/introduction-to-data-structure-binary-search-tree/140/introduction-to-a-bst/997/" target="_blank" rel="noopener">Validate Binary Search Tree</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; stackNode;</span><br><span class="line">        TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stackNode.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            <span class="keyword">if</span> (prev != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt;= prev-&gt;val) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = root;</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>平衡二叉树， node左侧所有节点的value小于node， 右侧所有节点的value大于node， 同时左右子树也都是BST。</li><li>使用中序遍历的方式解决。</li><li>prev初始化为nullptr，后面再让prev指向当前处理的节点root。这个技巧在之前的flatten binary tree 中也有使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Binary search tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flatten binary tree</title>
      <link href="/2019/07/12/flatten-binary-tree/"/>
      <url>/2019/07/12/flatten-binary-tree/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 114. <a href="https://leetcode.com/problems/flatten-binary-tree-to-linked-list/" target="_blank" rel="noopener">Flatten Binary Tree to Linked List</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatten</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        flatten (root-&gt;right);</span><br><span class="line">        flatten (root-&gt;left);</span><br><span class="line">        root-&gt;right = prev;</span><br><span class="line">        root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        prev = root;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TreeNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>程序中DFS过程先一直向右走（ flatten (root-&gt;right);），直到遇到空节点再一直向左走（flatten (root-&gt;left);），直到遇到空节点再处理节点本身，这是典型的R - L - V 顺序的后续遍历。 处理完node 的 右子树、左子树后 再处理node， 最后让prev指向node。<br>例如</p><p><img src="//zhhp1001.github.io/2019/07/12/flatten-binary-tree/1.png" alt></p><ul><li>root指针一直向右走，直到走到节点6，它的rc为空，flatten(6-&gt;right) return， 于是运行下一句 flatten(6-&gt;left), 6的lc也为空， 于是return，这样6的右、左都处理完了， 开始设置6本身。 设置好后让prev指向6…后面以此类推。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断是否为平衡二叉树</title>
      <link href="/2019/07/11/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/07/11/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-110-Balanced-Binary-Tree"><a href="#LeetCode-110-Balanced-Binary-Tree" class="headerlink" title="LeetCode 110. Balanced Binary Tree"></a>LeetCode 110. <a href="https://leetcode.com/problems/balanced-binary-tree/" target="_blank" rel="noopener">Balanced Binary Tree</a></h1><h2 id="方法一-（top-down）"><a href="#方法一-（top-down）" class="headerlink" title="方法一 （top down）"></a>方法一 （top down）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depth</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max (depth(root-&gt;left), depth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算左右子树的高度</span></span><br><span class="line">        <span class="keyword">int</span> depthLeft = depth(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> depthRight = depth (root-&gt;right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 depth()函数来计算 树的高度。<br>在isBalanced()中判断左右子树的高度差（绝对值）是否小于等于1， 并且左右子树也都是平衡二叉树。 这种自顶向下的方法没计算一个点的深度就要把它的所有子代遍历一遍，这样会产生大量的重复计算。</p><h2 id="方法二-bottom-up"><a href="#方法二-bottom-up" class="headerlink" title="方法二 (bottom up)"></a>方法二 (bottom up)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DFS(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFS</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftDepth = DFS(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (leftDepth == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> rightDepth = DFS(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (rightDepth == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(leftDepth - rightDepth) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(leftDepth, rightDepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用后序遍历的方式遍历二叉树的每一个节点，在遍历到每一个节点之前就已经遍历了它的左右子树，在遍历每个节点时记录它的深度。（某一节点的深度等于它到叶节点的路径长度）</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>getline()</title>
      <link href="/2019/07/10/getline/"/>
      <url>/2019/07/10/getline/</url>
      
        <content type="html"><![CDATA[<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream&amp; <span class="title">getline</span> <span class="params">(istream&amp; is, <span class="built_in">string</span>&amp; str, <span class="keyword">char</span> delim)</span></span>;</span><br></pre></td></tr></table></figure><p>delim(分隔符)，表示遇到这个字符停止读入，系统默认该字符为’\n’ 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> line;</span><br><span class="line">getline (<span class="built_in">cin</span>, line, <span class="string">'*'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>当输入 24gm is * the best ，时 读入输入流的只有 24gm is， <em>后面的并没有存入line中。<br>注意， 由于此时delim设定为`</em><code>所以即使输入 回车键  也不会停止读入，只有遇到</code>*` 时才会停止读入。</p><h2 id="c-读取以逗号为分隔符的一串数字"><a href="#c-读取以逗号为分隔符的一串数字" class="headerlink" title="c++读取以逗号为分隔符的一串数字"></a>c++读取以逗号为分隔符的一串数字</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    getline(<span class="built_in">cin</span>, s);</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> inter;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (is &gt;&gt; inter)</span><br><span class="line">    &#123;</span><br><span class="line">         v.push_back(inter);</span><br><span class="line">         is &gt;&gt; ch;  <span class="comment">//把数字后面的逗号读取走，这样下次循环时 is中就是从逗号后面的数字开始了</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;v.size();i++)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;v[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关于上述程序注释的说明：</span><br><span class="line">```C++</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> s1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">getline(<span class="built_in">cin</span>, s);</span><br><span class="line"><span class="function"><span class="built_in">istringstream</span> <span class="title">is</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="keyword">int</span> inter;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">is &gt;&gt; inter;</span><br><span class="line">is &gt;&gt; ch;</span><br><span class="line">is &gt;&gt; s1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"inter: "</span> &lt;&lt; inter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"ch: "</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"s1: "</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出如下：<br><img src="//zhhp1001.github.io/2019/07/10/getline/3.png" alt></p><hr><p>输入 24,35,55,85,135<br>输出 24 35 55 85 135</p><p>注意在vs中 进入黑色的命令行界面时 要注意输入法是否是英文， 否则会出现错误。<br>下图这样的输入 逗号后似乎还有空格， 这样程序输出就会错误。<br><img src="//zhhp1001.github.io/2019/07/10/getline/1.png" alt><br>正确输入如下<br><img src="//zhhp1001.github.io/2019/07/10/getline/2.png" alt></p><h3 id="stringstream通常是用来做数据转换的"><a href="#stringstream通常是用来做数据转换的" class="headerlink" title="stringstream通常是用来做数据转换的"></a>stringstream通常是用来做数据转换的</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> result=”<span class="number">10000</span>”;</span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;</span><br><span class="line">stream&lt;&lt;result;</span><br><span class="line">stream&gt;&gt;n;<span class="comment">//n等于10000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> getline() </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化、反序列化二叉树</title>
      <link href="/2019/07/10/%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/07/10/%E5%BA%8F%E5%88%97%E5%8C%96%E3%80%81%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-297-Serialize-and-Deserialize-Binary-Tree"><a href="#LeetCode-297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="LeetCode 297. Serialize and Deserialize Binary Tree"></a>LeetCode 297. <a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/" target="_blank" rel="noopener">Serialize and Deserialize Binary Tree</a></h1><h2 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">ostringstream</span> out;</span><br><span class="line">        serialize(root, out);</span><br><span class="line">        <span class="keyword">return</span> out.str();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(data)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> deserialize(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">serialize</span><span class="params">(TreeNode* root, <span class="built_in">ostringstream</span>&amp; out)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root) &#123;                         <span class="comment">//以前序遍历的顺序序列化二叉树</span></span><br><span class="line">            out &lt;&lt; root-&gt;val &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">            serialize(root-&gt;left, out);</span><br><span class="line">            serialize(root-&gt;right, out);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            out &lt;&lt; <span class="string">"# "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> val;</span><br><span class="line">        in &gt;&gt; val;</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="string">"#"</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> TreeNode(stoi(val));</span><br><span class="line">        root-&gt;left = deserialize(in);</span><br><span class="line">        root-&gt;right = deserialize(in);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="deserialize-实现二"><a href="#deserialize-实现二" class="headerlink" title="deserialize 实现二"></a>deserialize 实现二</h2> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> n;</span><br><span class="line">      <span class="keyword">char</span> ch;</span><br><span class="line">      in &gt;&gt; n;   <span class="comment">//从前序遍历顺序的 序列化二叉树中读取一个字符，转化为int。（&gt;&gt;运算符遇空白符e.g.空格、制表符、换行中止）</span></span><br><span class="line">      <span class="keyword">if</span>(in.fail()) &#123;   <span class="comment">//当读取失败时，in的fail() 返回 true。 (注1)</span></span><br><span class="line"></span><br><span class="line">          in.clear();   <span class="comment">// 调用流对象的clear()， 复位流的所有条件状态。</span></span><br><span class="line">          in &gt;&gt; ch;    <span class="comment">// 用一个char字符读取流中的下一位字符（即#）。</span></span><br><span class="line">          <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">      &#125;</span><br><span class="line">          </span><br><span class="line">      </span><br><span class="line">      TreeNode* root = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">      root-&gt;left = deserialize(in);</span><br><span class="line">      root-&gt;right = deserialize(in);</span><br><span class="line">      <span class="keyword">return</span> root;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>注1： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; val;</span><br></pre></td></tr></table></figure><p>如果我们输入Boo, 上面的读操作就会失败。代码中的输入运算符期待读取一个int, 但却得到了一个字符B。这样，cin 会进入错误状态（类似的，如果输入一个eof，cin也会进入错误状态）。一个流一旦发生错误，其上后续的IO操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。<br>确定一个流对象的状态的最简单的方法是将它当作一个条件来使用 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) <span class="comment">// while 循环检查 &gt;&gt; 表达式返回的流的状态。如果输入操作成功，流保持有效状态， 则条件为真</span></span><br></pre></td></tr></table></figure><h2 id="上述deserialize代码还可改为："><a href="#上述deserialize代码还可改为：" class="headerlink" title="上述deserialize代码还可改为："></a>上述deserialize代码还可改为：</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(<span class="built_in">istringstream</span>&amp; in)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> n;</span><br><span class="line">     <span class="keyword">char</span> ch;</span><br><span class="line">        </span><br><span class="line">     <span class="keyword">if</span>(!(in &gt;&gt; n)) &#123;   </span><br><span class="line">         in.clear();  </span><br><span class="line">         in &gt;&gt; ch;  </span><br><span class="line">         <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">     &#125;</span><br><span class="line">         </span><br><span class="line">     </span><br><span class="line">     TreeNode* root = <span class="keyword">new</span> TreeNode(n);</span><br><span class="line">     root-&gt;left = deserialize(in);</span><br><span class="line">     root-&gt;right = deserialize(in);</span><br><span class="line">     <span class="keyword">return</span> root;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总之就是记住 流一旦发生错误，其后续IO操作都会失败，所以下次IO操作前要先用clear()清空（或者叫复位）条件状态标志位。</p><h2 id="stoi"><a href="#stoi" class="headerlink" title="stoi()"></a>stoi()</h2><p>将string 转化为int  所谓stoi 是不是 string to int …<br>虽然在上面哪个题里 stringstream  也可以进行数据类型转换， 但是 从输入流里往 int类型对象里读入（存入）数据 遇到 # 就会中断。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 序列化、反序列化二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>把二叉树打印成多行</title>
      <link href="/2019/07/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/"/>
      <url>/2019/07/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%89%93%E5%8D%B0%E6%88%90%E5%A4%9A%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"><a href="#从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。" class="headerlink" title="从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。"></a>从上到下按层打印二叉树，同一层结点从左至右输出。每一层输出一行。</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Print(TreeNode* pRoot) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">    <span class="keyword">if</span> (pRoot == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; que;</span><br><span class="line">    que.push(pRoot);</span><br><span class="line">    <span class="keyword">while</span> (!que.empty()) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">int</span> n = que.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode* node = que.front();</span><br><span class="line">            que.pop();</span><br><span class="line">            level.push_back(node-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                que.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                que.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">             </span><br><span class="line">            res.push_back(level);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> res;           </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这里只用一个队列就可以了， 注意进入while循环时， 先计算队列的大小， 然后用for循环处理完这层的所有元素后再转到下一层的元素。</p><h1 id="清空vector中的所有元素"><a href="#清空vector中的所有元素" class="headerlink" title="清空vector中的所有元素"></a>清空vector中的所有元素</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 把二叉树打印成多行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树中和为某一值的路径</title>
      <link href="/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
      <url>/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-113-Path-Sum-II"><a href="#LeetCode-113-Path-Sum-II" class="headerlink" title="LeetCode 113. Path Sum II"></a>LeetCode 113. <a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">Path Sum II</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; paths;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">        DFS (root, sum, path, paths);</span><br><span class="line">        <span class="keyword">return</span> paths;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span> <span class="params">(TreeNode* root, <span class="keyword">int</span> sum, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; paths)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        path.push_back(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;val == sum) &#123;</span><br><span class="line">            paths.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        DFS (root-&gt;left, sum - root-&gt;val, path, paths);</span><br><span class="line">        DFS (root-&gt;right, sum - root-&gt;val, path, paths);</span><br><span class="line">        path.pop_back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>DFS 函数 返回值设为 void</li><li>path.pop_back()</li></ul><p>删除vector 容器末尾元素 </p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的最大深度</title>
      <link href="/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/"/>
      <url>/2019/07/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-104-Maximum-Depth-of-Binary-Tree"><a href="#LeetCode-104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="LeetCode 104. Maximum Depth of Binary Tree"></a>LeetCode 104. <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a></h1><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> leftTree = maxDepth (root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> rightTree = maxDepth (root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> max (leftTree, rightTree) + <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>当前节点的最大深度 = 左右子树最大深度的较大者 + 1</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span> <span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode*&gt; level;</span><br><span class="line">    level.push(root);</span><br><span class="line">    <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!level.empty()) &#123;</span><br><span class="line">        depth++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = level.size();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            TreeNode* node = level.front();</span><br><span class="line">            level.pop();</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                level.push(node-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                level.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> depth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代时间8ms 明显 优于 递归的24ms<br><img src="//zhhp1001.github.io/2019/07/09/二叉树的最大深度/1.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树的最大深度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断一棵树是否为另一棵树的子结构</title>
      <link href="/2019/07/09/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/"/>
      <url>/2019/07/09/%E5%88%A4%E6%96%AD%E4%B8%80%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E4%B8%BA%E5%8F%A6%E4%B8%80%E6%A3%B5%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-572-Subtree-of-Another-Tree"><a href="#LeetCode-572-Subtree-of-Another-Tree" class="headerlink" title="LeetCode 572. Subtree of Another Tree"></a>LeetCode 572. <a href="https://leetcode.com/problems/subtree-of-another-tree/submissions/" target="_blank" rel="noopener">Subtree of Another Tree</a></h1><h2 id="实现一"><a href="#实现一" class="headerlink" title="实现一"></a>实现一</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isSame(s, t)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSubtree (s-&gt;left, t) || isSubtree(s-&gt;right, t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span> <span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s &amp;&amp; !t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s || !t) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;val != t-&gt;val) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSame (s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题让我们求一个数是否是另一个树的子树，从题目中的第二个例子中可以看出，子树必须是从叶结点开始的，中间某个部分的不能算是子树，那么我们转换一下思路，是不是从s的某个结点开始，跟t的所有结构都一样，那么问题就转换成了判断两棵树是否相同，也就是Same Tree的问题了，这点想通了其实代码就很好写了，用递归来写十分的简洁，我们先从s的根结点开始，跟t比较，如果两棵树完全相同，那么返回true，否则就分别对s的左子结点和右子结点调用递归再次来判断是否相同，只要有一个返回true了，就表示可以找得到。</p><h2 id="实现二"><a href="#实现二" class="headerlink" title="实现二"></a>实现二</h2><p>The question is exactly similar to the Leetcode 100 Same Tree<br>Solution for Leetcode 100: <a href="https://leetcode.com/problems/same-tree/discuss/148340/CPP-Easy-to-Understand" target="_blank" rel="noopener">https://leetcode.com/problems/same-tree/discuss/148340/CPP-Easy-to-Understand</a></p><p>Also Check Leetcode 101 [Symmetric Tree]<a href="https://leetcode.com/problems/symmetric-tree/description/" target="_blank" rel="noopener">https://leetcode.com/problems/symmetric-tree/description/</a>)Leetcode 101 eh? :P</p><p>Okay so now you will be absolutely comfortable with this question. It just requires you to</p><p>1.Start with a node of tree s (lets call this s-node)<br>2.Compare the trees forming with root s-node and root t<br>3.If the trees match(leetcode 100 logic) then return true<br>4.Else go to step one and check for s-&gt;left || s-&gt;right</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(TreeNode* s, TreeNode* t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSameTree(s,t) || isSubtree(s-&gt;left,t) || isSubtree(s-&gt;right,t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Leetcode 100</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSameTree</span><span class="params">(TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span> &amp;&amp; q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">NULL</span> || q==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;val == q-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> isSameTree(p-&gt;left,q-&gt;left) &amp;&amp; isSameTree(p-&gt;right,q-&gt;right);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-101-Symmetric-Tree"><a href="#LeetCode-101-Symmetric-Tree" class="headerlink" title="LeetCode 101. Symmetric Tree"></a>LeetCode 101. <a href="https://leetcode.com/problems/symmetric-tree/" target="_blank" rel="noopener">Symmetric Tree</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> helper (root-&gt;left, root-&gt;right);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">helper</span> <span class="params">(TreeNode* left, TreeNode* right)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>) &#123;   <span class="comment">//两边同时为空，说明同时到头了，能走到这一步说明那些return false的不对称条件都没满足（也就是说到这为止这棵树是对称的）。</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left == <span class="literal">nullptr</span> || right == <span class="literal">nullptr</span>) &#123;  <span class="comment">//有一个是空的（那就两边不对称了）</span></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (left-&gt;val == right-&gt;val) &#123;  <span class="comment">//对称位置数值相等， 更新参数，继续前进。</span></span><br><span class="line">           <span class="keyword">return</span> helper (left-&gt;left, right-&gt;right) &amp;&amp; helper (left-&gt;right, right-&gt;left);</span><br><span class="line">       &#125; <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   </span><br><span class="line">               </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树的子结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重建二叉树</title>
      <link href="/2019/07/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/07/09/%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-105-重建二叉树from-VLR-amp-amp-LVR"><a href="#LeetCode-105-重建二叉树from-VLR-amp-amp-LVR" class="headerlink" title="LeetCode 105. 重建二叉树from VLR &amp;&amp; LVR"></a>LeetCode 105. <a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/discuss/34562/Sharing-my-straightforward-recursive-solution" target="_blank" rel="noopener">重建二叉树from VLR &amp;&amp; LVR</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> create (preorder, inorder, <span class="number">0</span>, preorder.size() - <span class="number">1</span>, <span class="number">0</span>, inorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">create</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe, <span class="keyword">int</span> is, <span class="keyword">int</span> ie)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(preorder[ps]);</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = is; i &lt;= ie; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == node-&gt;val) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = create (preorder, inorder, ps + <span class="number">1</span>, ps + pos - is, is, pos - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = create (preorder, inorder, pe - ie + pos + <span class="number">1</span>, pe, pos + <span class="number">1</span>, ie);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Let me explain the coordinates in the recursion. Very simply, we can see that the inorder traversal is divided into two parts, [is, pos-1] and [pos+1, ie] according to the root node pointed by pos.The first part contains pos - is elements, and the second part has ie- (pos +1)+1 = ie - pos elements.<br>Correspondingly, in preorder traversal, the elements in the [ps+1, ps+pos - is] intervals belong to the left subtree, and the elements in the [pe - (ie - pos)+1, pe] interval belong to the right subtree.</p><h1 id="LeetCode-106-重建二叉树from-LVR-amp-amp-LRV"><a href="#LeetCode-106-重建二叉树from-LVR-amp-amp-LRV" class="headerlink" title="LeetCode 106 重建二叉树from LVR &amp;&amp; LRV"></a>LeetCode 106 <a href="https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/" target="_blank" rel="noopener">重建二叉树from LVR &amp;&amp; LRV</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> create (inorder, postorder, <span class="number">0</span>, inorder.size() - <span class="number">1</span>, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="function">TreeNode* <span class="title">create</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; inorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; postorder, <span class="keyword">int</span> is, <span class="keyword">int</span> ie, <span class="keyword">int</span> ps, <span class="keyword">int</span> pe)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ps &gt; pe) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> TreeNode(postorder[pe]);</span><br><span class="line">    <span class="keyword">int</span> pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = is; i &lt;= ie; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[i] == node-&gt;val) &#123;</span><br><span class="line">            pos = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;left = create (inorder, postorder, is, pos - <span class="number">1</span>, ps, ps + pos - is - <span class="number">1</span>);</span><br><span class="line">    node-&gt;right = create (inorder, postorder, pos + <span class="number">1</span>, ie, pe - ie + pos, pe - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 重建二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Traits</title>
      <link href="/2019/07/04/Traits/"/>
      <url>/2019/07/04/Traits/</url>
      
        <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq100440110/article/details/51854673" target="_blank" rel="noopener">Tratis</a></p>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Traits </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指offer刷题计划</title>
      <link href="/2019/07/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/"/>
      <url>/2019/07/01/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>理想状态：<br>字符串（8题）    7.1<br>数组 （11题）    7.2<br>链表（8题）      7.3<br>二叉树 （12题）  7.4</p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><h2 id="string"><a href="#string" class="headerlink" title="string"></a><a href="https://www.nowcoder.com/practice/1c82e8cf713b4bbeb2a5b31cf5b0417c?tpId=13&tqId=11187&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">string</a></h2><p><img src="//zhhp1001.github.io/2019/07/01/剑指offer刷题计划/1.png" alt></p><p>string 与 char</p><h2 id="左旋转字符串"><a href="#左旋转字符串" class="headerlink" title="左旋转字符串"></a><a href="https://www.nowcoder.com/practice/12d959b108cb42b1ab72cef4d36af5ec?tpId=13&tqId=11196&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">左旋转字符串</a></h2><p>注意这个if条件，不要漏掉<br><img src="//zhhp1001.github.io/2019/07/01/剑指offer刷题计划/%E5%89%91%E6%8C%87offer%E5%88%B7%E9%A2%98%E8%AE%A1%E5%88%92" alt></p><h2 id="翻转单词顺序列"><a href="#翻转单词顺序列" class="headerlink" title="翻转单词顺序列"></a><a href="https://www.nowcoder.com/practice/3194a4f4cf814f63919d0790578d51f3?tpId=13&tqId=11197&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">翻转单词顺序列</a></h2><p><code>str += &#39; &#39;</code>， 在字符串末尾添加一个空格字符。  注意到此处str长度 +1 了， 所以后面用到的str.size() 也已经+1了， 这一点很容易注意不到。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">ReverseSentence</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        str += <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] == <span class="string">' '</span>) &#123;</span><br><span class="line">                reverse (str, j, i - <span class="number">1</span>);</span><br><span class="line">                j = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        str = str.substr(<span class="number">0</span>, str.size() - <span class="number">1</span>);</span><br><span class="line">        reverse (str, <span class="number">0</span>, str.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverse</span> <span class="params">(<span class="built_in">string</span>&amp; str, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line">            swap (str[begin], str[end]);</span><br><span class="line">            begin++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="把字符转换成整数"><a href="#把字符转换成整数" class="headerlink" title="把字符转换成整数"></a><a href="https://www.nowcoder.com/practice/1277c681251b4372bdef344468e4f26e?tpId=13&tqId=11202&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">把字符转换成整数</a></h2><p>这道题注意 这个步骤  <code>res = res * 10 + str[i] - &#39;0&#39;</code> 这里 <code>- &#39;0&#39;</code>的作用是什么？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">StrToInt</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> signal = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (str[<span class="number">0</span>] == <span class="string">'-'</span>) &#123;</span><br><span class="line">            signal = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (str[<span class="number">0</span>] == <span class="string">'-'</span> || str[<span class="number">0</span>] == <span class="string">'+'</span>) ? <span class="number">1</span> : <span class="number">0</span>; i &lt; str.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] &gt;= <span class="string">'0'</span> &amp;&amp; str[i] &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                res = res * <span class="number">10</span> + str[i] - <span class="string">'0'</span>;</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res * signal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a><a href="https://www.nowcoder.com/practice/253d2c59ec3e4bc68da16833f79a38e4?tpId=13&tqId=11208&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">快慢指针</a></h1><p>不能对一个nullptr进行操作。</p><p><img src="//zhhp1001.github.io/2019/07/01/剑指offer刷题计划/3.png" alt></p><p>pSlow 指向下一个位置后，要判断一下这个新位置是否为空，如果非空，pFast才能指向新位置的下一个位置。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>permutation &amp; combination</title>
      <link href="/2019/06/27/permutation%20+%20combination/"/>
      <url>/2019/06/27/permutation%20+%20combination/</url>
      
        <content type="html"><![CDATA[<h1 id="LeetCode-next-permutation"><a href="#LeetCode-next-permutation" class="headerlink" title="LeetCode next permutation"></a>LeetCode <a href="https://leetcode.com/problems/next-permutation/discuss/13867/C%2B%2B-from-Wikipedia" target="_blank" rel="noopener">next permutation</a></h1><p>这道题的讨论区解答很详细， 特别注意一下 <code>reverse(nums.begin(), nums.end())</code> 参数是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">nextPermutation</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        <span class="keyword">int</span> l;</span><br><span class="line">        <span class="keyword">for</span> (k = n - <span class="number">2</span>; k &gt;= <span class="number">0</span>; k--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &lt; nums[k + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            reverse (nums.begin(), nums.end());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (l = n - <span class="number">1</span>; l &gt; k; l--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[k] &lt; nums[l]) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            swap (nums[k], nums[l]);</span><br><span class="line">            reverse (nums.begin() + k + <span class="number">1</span>, nums.end());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-Permutation"><a href="#LeetCode-Permutation" class="headerlink" title="LeetCode Permutation"></a>LeetCode <a href="https://leetcode.com/problems/permutations/discuss/18360/C%2B%2B-backtracking-and-nextPermutation" target="_blank" rel="noopener">Permutation</a></h1><h2 id="使用-vector-amp-与-第二次swap"><a href="#使用-vector-amp-与-第二次swap" class="headerlink" title="使用 vector&amp; 与 第二次swap"></a>使用 vector<int>&amp; 与 第二次swap</int></h2><p>整个过程只存在一个nums,改变一个nums的操作，就相当于整个流程中的nums都做了相同的变化，因此需要在DFS后再进行一次交换。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt;res;</span><br><span class="line">        DFS(res, nums, 0);</span><br><span class="line">        return res;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; res, vector&lt;int&gt;&amp; nums, int pos)&#123;</span><br><span class="line">        if(pos == nums.size())&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = pos; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">            DFS(res, nums, pos + 1);</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用-传值-并去掉第二次的交换"><a href="#使用-传值-并去掉第二次的交换" class="headerlink" title="使用 传值 并去掉第二次的交换"></a>使用 传值 并去掉第二次的交换</h2><p>每次调用DFS都会copy一个nums，因此不用担心调用DFS会对之前的nums有影响，也就不用在调用完递归函数后再进行交换了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; permute(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;res;</span><br><span class="line">        DFS(res, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())&#123;</span><br><span class="line">            res.push_back(nums);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            swap(nums[pos], nums[i]);</span><br><span class="line">            DFS(res, nums, pos + <span class="number">1</span>);</span><br><span class="line">     </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> permutation &amp; combination </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>static</title>
      <link href="/2019/06/27/static/"/>
      <url>/2019/06/27/static/</url>
      
        <content type="html"><![CDATA[<ul><li><p>加了<code>static</code>关键字的全局变量只能在本文件中使用。</p></li><li><p>static 定义的静态局部变量分配在数据段上。普通的局部变量分配在栈上，会因为函数栈帧的释放而被释放掉。</p></li><li><p>对一个类中成员变量和成员函数来说， 加了static关键字， 则此变量/函数就没有了this指针， 必须通过类名才能访问。</p></li></ul><p>C++.pdf </p><ol start="34"><li></li><li>C++调用C函数需要extern C, 因为C语言没有函数重载.</li><li><code>new</code> 和 <code>delete</code> 是 C++的关键字， 而 <code>malloc</code> 和 <code>free</code> 是 C语言的库函数， 后者使用必须指明申请内存空间的大小， 对于类类型的对象， 后者不会调用构造函数和析构函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> static </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="/2019/06/26/%E9%80%92%E5%BD%92/"/>
      <url>/2019/06/26/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<ul><li>递归、回溯、DFS</li><li>循环是一种特殊的递归，可以称为不需要栈的递归，或者尾递归。<h1 id="好文"><a href="#好文" class="headerlink" title="好文"></a><a href="https://blog.csdn.net/SpeedMe/article/details/21654357#commentBox" target="_blank" rel="noopener">好文</a></h1></li></ul><h2 id="例子-给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了-d格式码，它就会执行类似处理。"><a href="#例子-给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了-d格式码，它就会执行类似处理。" class="headerlink" title="例子 给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了%d格式码，它就会执行类似处理。"></a>例子 给出一个值4267，我们需要依次产生字符‘4’，‘2’，‘6’，和‘7’。就如在printf函数中使用了%d格式码，它就会执行类似处理。</h2><p>分析：首先我们会想到用4267取余，然后除以10再区域，如此循环。但这样输出的顺序不会是7,6,2,4吗？于是我们就利用递归的堆栈结构的特性：先进后出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">recursion(<span class="number">4267</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">recursion</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> quotient ;</span><br><span class="line">quotient = value/<span class="number">10</span> ;</span><br><span class="line"><span class="keyword">if</span>(quotient!=<span class="number">0</span>)&#123; recursion(quotient) ;&#125;</span><br><span class="line">System.out.println(value%<span class="number">10</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归是如何帮助我们以正确的顺序打印这些字符呢？下面是这个函数的工作流程。</p><ol><li>将参数值除以10</li><li>如果quotient的值为非零，调用binary-to-ascii打印quotient当前值的各位数字</li><li>接着，打印步骤1中除法运算的余数</li></ol><p>注意在第2个步骤中，我们需要打印的是quotient当前值的各位数字。我们所面临的问题和最初的问题完全相同，只是变量quotient的 值变小了。我们用刚刚编写的函数（把整数转换为各个数字字符并打印出来）来解决这个问题。由于quotient的值越来越小，所以递归最终会终止。<br>　　一旦你理解了递归，阅读递归函数最容易的方法不是纠缠于它的执行过程，而是<strong>相信</strong>递归函数会顺利完成它的任务。如果你的每个步骤正确无误，你的限制条件设置正确，并且每次调用之后更接近限制条件，递归函数总是能正确的完成任务。<br>　　但是，为了理解递归的工作原理，你需要追踪递归调用的执行过程，所以让我们来进行这项工作。追踪一个递归函数的执行过程的关键是理解函数中所声明的变量是如何存储的。当函数被调用时，它的变量的空间是创建于运行时堆栈上的。以前调用的函数的变量扔保留在堆栈上，但他们被新函数的变量所掩盖，因此是不能被访问的。<br>　　当递归函数调用自身时，情况于是如此。每进行一次新的调用，都将创建一批变量，他们将掩盖递归函数前一次调用所创建的变量。当我追踪一个递归函数的执行过程时，必须把分数不同次调用的变量区分开来，以避免混淆。<br>　　程序中的函数有两个变量：参数value和局部变量quotient。下面的一些图显示了堆栈的状态，当前可以访问的变量位于栈顶。所有其他调用的变量饰以灰色的阴影，表示他们不能被当前正在执行的函数访问。<br>假定我们以4267这个值调用递归函数。当函数刚开始执行时，堆栈的内容如下图所示：<br><img src="//zhhp1001.github.io/2019/06/26/递归/1.jpg" alt></p><p>执行除法之后，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/2.jpg" alt></p><p>接着，if语句判断出quotient的值非零，所以对该函数执行递归调用。当这个函数第二次被调用之初，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/3.jpg" alt></p><p>堆栈上创建了一批新的变量，隐藏了前面的那批变量，除非当前这次递归调用返回，否则他们是不能被访问的。再次执行除法运算之后，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/4.jpg" alt></p><p>quotient的值现在为42，仍然非零，所以需要继续执行递归调用，并再创建一批变量。在执行完这次调用的出发运算之后，堆栈的内容如下：<br><img src="//zhhp1001.github.io/2019/06/26/递归/5.jpg" alt></p><p>此时，quotient的值还是非零，仍然需要执行递归调用。在执行除法运算之后，堆栈的内容如下:<br><img src="//zhhp1001.github.io/2019/06/26/递归/6.jpg" alt></p><p>不算递归调用语句本身，到目前为止所执行的语句只是除法运算以及对quotient的值进行测试。由于递归调用这些语句重复执行，所以它的效果 类似循环：当quotient的值非零时，把它的值作为初始值重新开始循环。但是，递归调用将会保存一些信息（这点与循环不同），也就好是保存在堆栈中的 变量值。这些信息很快就会变得非常重要。<br>　　现在quotient的值变成了零，递归函数便不再调用自身，而是开始打印输出。然后函数返回，并开始销毁堆栈上的变量值。<br>每次调用putchar得到变量value的最后一个数字，方法是对value进行模10取余运算，其结果是一个0到9之间的整数。把它与字符常量‘0’相加，其结果便是对应于这个数字的ASCII字符，然后把这个字符打印出来。<br><img src="//zhhp1001.github.io/2019/06/26/递归/7.jpg" alt></p><p>接着函数返回，它的变量从堆栈中销毁。接着，递归函数的前一次调用重新继续执行，她所使用的是自己的变量，他们现在位于堆栈的顶部。因为它的value值是42，所以调用putchar后打印出来的数字是2。输出42：<br><img src="//zhhp1001.github.io/2019/06/26/递归/8.jpg" alt></p><p>接着递归函数的这次调用也返回，它的变量也被销毁，此时位于堆栈顶部的是递归函数再前一次调用的变量。递归调用从这个位置继续执行，这次打印的数字是6。在这次调用返回之前，堆栈的内容如下,输出426：<br><img src="//zhhp1001.github.io/2019/06/26/递归/9.jpg" alt></p><p>现在我们已经展开了整个递归过程，并回到该函数最初的调用。这次调用打印出数字7，也就是它的value参数除10的余数。输出4267：<br><img src="//zhhp1001.github.io/2019/06/26/递归/10.jpg" alt></p><h2 id="递归的基本原理："><a href="#递归的基本原理：" class="headerlink" title="递归的基本原理："></a>递归的基本原理：</h2><p>　　１　每一次函数调用都会有一次返回．当程序流执行到某一级递归的结尾处时，它会转移到前一级递归继续执行．</p><p>　　２　递归函数中，位于递归调用前的语句和各级被调函数具有相同的顺序．</p><p>　　３　每一级的函数调用都有自己的局部变量．</p><p>　　４　递归函数中，<strong>位于递归调用语句后的语句的执行顺序和各个被调用函数的顺序相反</strong>．</p><pre><code>    　　 即位于递归函数入口前的语句，由外往里执行；位于递归函数入口后面的语句，由里往外执行。</code></pre><p>　　５　虽然每一级递归有自己的变量，但是函数代码并不会得到复制．</p><p>　　６　递归函数中必须包含可以终止递归调用的语句．</p><h2 id="递归算法一般用于解决三类问题："><a href="#递归算法一般用于解决三类问题：" class="headerlink" title="递归算法一般用于解决三类问题："></a>递归算法一般用于解决三类问题：</h2><p>　　(1)数据的定义是按递归定义的。(Fibonacci函数)</p><p>　　(2)问题解法按递归算法实现。(回溯)</p><p>　　(3)数据的结构形式是按递归定义的。(树的遍历，图的搜索)</p><h1 id="To-Iterate-Human-to-Recurse-Divine"><a href="#To-Iterate-Human-to-Recurse-Divine" class="headerlink" title="To Iterate,Human; to Recurse, Divine"></a>To Iterate,Human; to Recurse, Divine</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">count++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"B&gt;"</span>;</span><br><span class="line"><span class="keyword">for</span> (i; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I&gt;"</span>;</span><br><span class="line">recur(i + <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"R&gt;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Solution solve;</span><br><span class="line">solve.recur(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我改变recur中 n 的值， 来看看输出的变化：</p><p><img src="//zhhp1001.github.io/2019/06/26/递归/1.png" alt="n = 1"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/2.png" alt="n = 2"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/3.png" alt="n = 3"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/4.png" alt="n = 4"><br>在for循环中添加变量j </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"I&gt;"</span>;</span><br><span class="line">recur(i + <span class="number">1</span>, n);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"R&gt;"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="//zhhp1001.github.io/2019/06/26/递归/5.png" alt="n = 2"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/6.png" alt="n = 3"></p><p><img src="//zhhp1001.github.io/2019/06/26/递归/7.png" alt="n = 4"></p><p>太疯狂了！ for 循环 加一个变量， 或者增加一层循环， 程序的执行次数就大大增加…所以，阅读递归函数最容易的方法不是纠缠于它的执行过程，而是<strong>相信</strong>递归函数会顺利完成它的任务。</p><h1 id="Leetcode-Swap-Nodes-in-Pairs"><a href="#Leetcode-Swap-Nodes-in-Pairs" class="headerlink" title="Leetcode Swap Nodes in Pairs"></a>Leetcode <a href="https://leetcode.com/explore/learn/card/recursion-i/250/principle-of-recursion/1681/discuss/11271/Simple-implementation-with-C++" target="_blank" rel="noopener">Swap Nodes in Pairs</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span> <span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tmp = head-&gt;next;</span><br><span class="line">        head-&gt;next = swapPairs (tmp-&gt;next);</span><br><span class="line">        tmp-&gt;next = head;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-Pascal’s-Triangle"><a href="#LeetCode-Pascal’s-Triangle" class="headerlink" title="LeetCode Pascal’s Triangle"></a>LeetCode <a href="https://leetcode.com/explore/learn/card/recursion-i/251/scenario-i-recurrence-relation/1659" target="_blank" rel="noopener">Pascal’s Triangle</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; generate(<span class="keyword">int</span> numRows) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res(numRows);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numRows; i++) &#123;</span><br><span class="line">            res[i].resize(i + <span class="number">1</span>);</span><br><span class="line">            res[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            res[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">                res[i][j] = res[i - <span class="number">1</span>][j - <span class="number">1</span>] + res[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>注意因为后面有对res 元素的操作， 所以开头定义 vector&lt;vector<int>&gt; 时 要注意初始化。<br>假设numRows = 5， 那么我们需要首先将<code>vector&lt;vector&lt;int&gt;&gt;</code>初始化为<br>[<br>[]<br>[]<br>[]<br>[]<br>[]<br>]否则后面的res[i][j]等操作就是在null上的无意义操作了（似乎可以看一下stl源码剖析，进一步理解vector的迭代器）。</int></li><li>resize()</li></ul>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生日过后</title>
      <link href="/2019/06/26/%E7%94%9F%E6%97%A5%E8%BF%87%E5%90%8E/"/>
      <url>/2019/06/26/%E7%94%9F%E6%97%A5%E8%BF%87%E5%90%8E/</url>
      
        <content type="html"><![CDATA[<p>感觉一直是找不到确切的方向，以至一直坚持不下来，软件、算法，找工作到底想要什么还是不确定。专利和大论文也是没有什么想法。一点点做吧。6.26，赶在这个六月结束前搞好专利吧先。</p>]]></content>
      
      
      <categories>
          
          <category> 记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 想 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯法</title>
      <link href="/2019/06/25/%E5%9B%9E%E6%BA%AF%E6%B3%95/"/>
      <url>/2019/06/25/%E5%9B%9E%E6%BA%AF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer矩阵中的路径"><a href="#剑指offer矩阵中的路径" class="headerlink" title="剑指offer矩阵中的路径"></a>剑指offer<a href="https://www.nowcoder.com/practice/c61c6999eecb4b8f88a98f66b273a3cc?tpId=13&tqId=11218&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">矩阵中的路径</a></h1>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>打印矩阵</title>
      <link href="/2019/06/25/%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/"/>
      <url>/2019/06/25/%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="剑指offer-顺时针打印矩阵"><a href="#剑指offer-顺时针打印矩阵" class="headerlink" title="剑指offer 顺时针打印矩阵"></a>剑指offer <a href="https://www.nowcoder.com/practice/9b4c81a02cd34f76be2659fa0d54342a?tpId=13&tqId=11172&tPage=1&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking" target="_blank" rel="noopener">顺时针打印矩阵</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; printMatrix (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; matrix ) &#123;</span><br><span class="line">            <span class="keyword">int</span> rows = matrix.size();</span><br><span class="line">            <span class="keyword">int</span> cols = matrix[<span class="number">0</span>].size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">            <span class="keyword">if</span> (rows == <span class="number">0</span> ) &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> left = <span class="number">0</span>, right = cols - <span class="number">1</span>, top = <span class="number">0</span>, bottom = rows - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (top &lt;= bottom &amp;&amp; left &lt;= right) &#123;</span><br><span class="line">                <span class="comment">//从左到右</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = left; i &lt;=right; i++) &#123;</span><br><span class="line">                    result.push_back(matrix[top][i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 从上到下</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = top + <span class="number">1</span>; i &lt;= bottom; i++) &#123;</span><br><span class="line">                    result.push_back(matrix[i][right]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从右到左</span></span><br><span class="line">                <span class="keyword">if</span> (top != bottom) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = right - <span class="number">1</span>; i &gt;= left; i--) &#123;</span><br><span class="line">                        result.push_back(matrix[bottom][i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从下到上</span></span><br><span class="line">                <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = bottom - <span class="number">1</span>; i &gt; top; i--) &#123;</span><br><span class="line">                        result.push_back(matrix[i][left]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                left++, right--, top++, bottom--;  <span class="comment">//更新控制量</span></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从右向左和从下到上 要 分别考虑 单行 、 单列 两种特殊情况。 一圈结束后（→，↓，←，↑）记得更新控制量 i.e. 一圈的四个边界。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 旋转打印矩阵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sort</title>
      <link href="/2019/06/23/sort/"/>
      <url>/2019/06/23/sort/</url>
      
        <content type="html"><![CDATA[<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><p><img src="//zhhp1001.github.io/2019/06/23/sort/insert.gif" alt><br>每次把一个新数据插入到有序队列中的合适位置里。</p><p>假设有一组无序序列 R<sub>0</sub>, R<sub>1</sub>, … , R<sub>N-1</sub>。</p><p>(1) 我们先将这个序列中下标为 0 的元素视为元素个数为 1 的有序序列。</p><p>(2) 然后，我们要依次把  R<sub>0</sub>, R<sub>1</sub>, … , R<sub>N-1</sub> 插入到这个有序序列中。所以，我们需要一个外部循环，从下标 1 扫描到 N-1 。</p><p>(3) 接下来描述插入过程。假设这是要将 R<sub>i</sub> 插入到前面有序的序列中。由前面所述，我们可知，插入 R<sub>i</sub>时，前 i-1 个数肯定已经是有序了。</p><p>所以我们需要将 R<sub>i</sub> 和R<sub>0</sub> ~  R<sub>i-1</sub> 进行比较，确定要插入的合适位置。这就需要一个内部循环，我们一般是从后往前比较，即从下标 i-1 开始向 0 进行扫描。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; insertionSort(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (input.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = result[i];</span><br><span class="line"><span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; result[j] &gt; temp; j--) &#123;</span><br><span class="line">result[j + <span class="number">1</span>] = result[j];</span><br><span class="line">&#125;</span><br><span class="line">result[j + <span class="number">1</span>] = temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : iv) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve = insertionSort(iv);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; solve.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; solve[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h1><p>每趟从待排序的序列中选出最小的元素，顺序放在已排序的序列末尾。</p><ul><li>从待排序序列中，找到关键字最小的元素；</li><li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li><li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。<br><img src="//zhhp1001.github.io/2019/06/23/sort/select.gif" alt></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; selectSort(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; input) &#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (input.empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">result = input;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.size(); i++) &#123;</span><br><span class="line"><span class="keyword">int</span> index = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; result.size(); j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (result[index] &gt; result[j]) &#123;</span><br><span class="line">index = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (index == i) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">swap(result[index], result[i]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第"</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">"次循环:  "</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : result) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; iv(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前 ："</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : iv) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; solve = selectSort(iv);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h1><p>快速排序的精髓在于partition()，我们把第一个元素作为pivot的培养对象，经过一次partition()后，数组分为两部分，第一部分<code>&lt;=</code>pivot,第二部分<code>&gt;=</code>pivot。<br>快速排序算法需要两个指针 i、j 分别指向数组的两端， i之前的元素 <code>&lt;=</code>pivot, j之后的元素 <code>&gt;=</code>pivot。两个指针向中间移动，直到遇到一个不符合条件的元素才停止移动。当两个指针都停下时，交换i 、 j 指针指向的元素。<br>重复这个过程。</p><p><img src="//zhhp1001.github.io/2019/06/23/sort/quick.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (...) &#123;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &lt;= pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (a[i] &gt;= pivot) j--;</span><br><span class="line">    swap(a[i], a[j]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了循环就自然要考虑循环的终止条件。可以发现，当i、j两个指针穷尽了各自的区间时循环应该停止， 此时两指针处于 <strong>交错状态</strong>，i指向 <code>&gt;=</code>区域的第一个元素， j指向<code>&lt;=</code>区域的最后一个元素。<br><img src="//zhhp1001.github.io/2019/06/23/sort/sort2.png" alt><br>此时不应该再进行交换操作了。 这时，我们把pivot移动到j处，并且return j这位置， 这样，一次partition操作就完成了。<br>关于i、j两个指针的while循环有数组越界的危险， 假设所有元素都&lt;=pivot， 那么i会越界；假设所有元素都&gt;=pivot，那么j会越界。因此要加上<code>i&lt;=j</code>这个判断来避免越界（注意要有<code>=</code>， 保证i、j会交错）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = first;</span><br><span class="line">    <span class="keyword">int</span> j = last;</span><br><span class="line">    <span class="keyword">int</span> pivot = a[first];</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=j &amp;&amp; a[i] &lt;= pivot) i++;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=j &amp;&amp; a[i] &gt;= pivot) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">        swap (a[i], a[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">swap (a[first],a[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是完整的程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = first;</span><br><span class="line"><span class="keyword">int</span> j = last;</span><br><span class="line"><span class="keyword">int</span> p = first;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; vec[i] &lt;= vec[p]) i++;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= j &amp;&amp; vec[j] &gt;= vec[p]) j--;</span><br><span class="line"><span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">swap(vec[i], vec[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">swap(vec[p], vec[j]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; vec, <span class="keyword">int</span> first, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (last &gt; first) &#123;</span><br><span class="line"><span class="keyword">int</span> pivot = partition(vec, first, last);</span><br><span class="line">quickSort (vec, first, pivot - <span class="number">1</span>);</span><br><span class="line">quickSort (vec, pivot + <span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; input(a, a + <span class="keyword">sizeof</span>(a) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序前： "</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : input) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"排序后： "</span>;</span><br><span class="line">quickSort(input, <span class="number">0</span>, input.size() - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> e : input) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h1><h1 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h1>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影调</title>
      <link href="/2019/06/18/%E5%BD%B1%E8%B0%83/"/>
      <url>/2019/06/18/%E5%BD%B1%E8%B0%83/</url>
      
        <content type="html"><![CDATA[<p>黑白明暗层次变化是影像的骨架和节奏，而色彩则是附着其上的血肉和韵律。亚当斯把0<del>255这个颜色范围分成了0</del>X十一个区，其中0和X分别是纯黑纯白，</p><ul><li>从全黑到全白的0区~X区是<em>全影调幅度</em>；</li><li>I区~IX区是具有基本影调值的<em>有效幅度</em>；</li><li>II~VIII是能够清晰地表现出影调纹理质感的<em>纹理幅度</em>。<img src="//zhhp1001.github.io/2019/06/18/影调/%E4%BA%9A%E5%BD%93%E6%96%AF.png" alt></li></ul><h1 id="影调的划分"><a href="#影调的划分" class="headerlink" title="影调的划分"></a>影调的划分</h1><h2 id="根据画面明暗基调关系划分影调"><a href="#根据画面明暗基调关系划分影调" class="headerlink" title="根据画面明暗基调关系划分影调"></a>根据画面明暗基调关系划分影调</h2><p>对于影调，我们首先可以根据画面中的明暗基调关系（黑白关系）进行划分。在灰阶的11个区域中，0代表纯黑，10代表纯白，我们可以把11级分为低明度、中明度、高明度3个级别。<br><img src="//zhhp1001.github.io/2019/06/18/影调/%E6%98%8E%E6%9A%97.png" alt></p><ul><li>低调（暗调），给人神秘、含蓄、肃穆、庄重、粗豪、倔强和力量的视觉感受。低调形成的基础为黑色，但照片并不是黑成一篇，必须在相应的位置辅以亮色（高光），正因为有大片的暗色调烘托陪衬，小面积的亮色就会显得突出而成为整个画面的视觉中心。</li><li>中调（灰调），有平和与疏淡的感觉。</li><li>高调（亮调），视觉感受为轻盈、纯洁、明快、清秀、宁静、淡雅与舒适。高调照片在浅而苏雅的影调环境中，局部少量的暗色也是必不可少的，这些黑暗影调所构成的部分往往成为画面的视觉中心。<h2 id="根据画面明度对比强弱划分影调"><a href="#根据画面明度对比强弱划分影调" class="headerlink" title="根据画面明度对比强弱划分影调"></a>根据画面明度对比强弱划分影调</h2>在一张照片中，如果明暗灰阶相差5级以上，称为<strong>长调</strong>，画面对比很强烈。相差3~5级以内，称为短调，画面对比很弱，整体层次比较平淡。</li></ul><p>P240</p>]]></content>
      
      
      <categories>
          
          <category> 摄影 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 影调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从对象切割说起</title>
      <link href="/2019/06/18/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2%E8%AF%B4%E8%B5%B7/"/>
      <url>/2019/06/18/%E4%BB%8E%E5%AF%B9%E8%B1%A1%E5%88%87%E5%89%B2%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>临时对象</title>
      <link href="/2019/06/18/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/06/18/%E4%B8%B4%E6%97%B6%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p>临时对象（由编译器定义的一个没有命名的非堆（non-heap）对象），不出现在C++代码中，但是确实存在。这种未命名对象有两种产生条件：</p><ul><li>为了使函数调用成功而进行的隐式类型转换。</li><li>函数返回对象。</li></ul><h1 id="C-中对临时变量的引用必须是-const引用。"><a href="#C-中对临时变量的引用必须是-const引用。" class="headerlink" title="C++ 中对临时变量的引用必须是 const引用。"></a>C++ 中对临时变量的引用必须是 const引用。</h1><p>如果一个参数是以一个非const 引用 传入的，那么C++编译器就有理由相信我们传入的参数在函数中是可以被修改的，并且这个修改的变量在函数外也是可以使用的；如果我们把一个<strong>临时对象</strong>当作非const引用参数传进来，则由于对临时变量的修改在函数内部，临时变量在使用完成后就被释放，所以我们修改一个临时变量实际上是<strong>没有意义</strong>的，因此，C++编译器就加入了临时变量不能作为非const引用的这个语义限制。<br>在编译器告诉你错误比在运行期时遇到问题更为友好。</p>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stack object / heap object</title>
      <link href="/2019/06/17/stack-object%20+%20heap-object/"/>
      <url>/2019/06/17/stack-object%20+%20heap-object/</url>
      
        <content type="html"><![CDATA[<h1 id="堆对象"><a href="#堆对象" class="headerlink" title="堆对象"></a>堆对象</h1><h1 id="栈对象"><a href="#栈对象" class="headerlink" title="栈对象"></a>栈对象</h1><pre><code>由编译器自动分配和释放， 用于保存一些局部变量、函数的参数等。</code></pre><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><ul><li><p>栈对象的优势是在适当的时候自动生成，又在适当的时候自动销毁，不需要我们来费心；而且，栈对象的创建速度比堆对象快，因为分配堆对象时会调用 operator new操作， operator new 会采用某种内存空间搜索算法， 而该搜索过程可能很费时间， 栈对象的产生则仅仅需要移动栈顶指针。 但要注意， 栈空间容量较小（1~2M），所以体积较大的对象不适合在栈中分配，特别要注意递归函数最好不要使用栈对象，因为随着递归深度的增加，所需栈空间也会线性增加，当所需栈空间不够时，便会导致栈溢出，产生运行时错误。</p></li><li><p>因此，当你明确要使用的类型数量时， 使用 Object objec;<br>当你不知道你要创建的类型有多少个时， 使用 Object* object = new Object();</p></li><li><p>栈对象相当于局部对象，堆对象相当于一种能共享于各函数或语句块的对象。栈对象在语句块执行完就自动销毁，堆对象需要手动销毁。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>专利</title>
      <link href="/2019/06/17/%E4%B8%93%E5%88%A9/"/>
      <url>/2019/06/17/%E4%B8%93%E5%88%A9/</url>
      
        <content type="html"><![CDATA[<h1 id="实用新型专利"><a href="#实用新型专利" class="headerlink" title="实用新型专利"></a>实用新型专利</h1><p>只要有一些技术改进就可以申请实用新型专利，要注意的是，只有设计产品构造、形状或其结合时，才可申请实用新型专利。实用新型专利保护 10 年。  </p><p>发明和实用新型专利申请应提交的文件基本相同，即：<strong>请求书</strong>、<strong>说明书</strong>、<strong>说明书附图</strong>、<strong>权利要求书</strong>、<strong>说明书摘要</strong>及<strong>摘要附图</strong>。但某些发明专利申请可以不提交说明书附图和摘要附图。</p><p>权利要求书应当以说明书为依据，其中的权利要求应当受说明书的支持，其提出的保护范围应当与说明书中公开的内容相适应。 </p><p>摘要应当写明发明的名称、所属技术领域、要解决的技术问题、主要技术特征和用途。不得有商业性宣传用语和过多的对发明创造优点的描述。不得超过<strong>300</strong>个字。</p><p>说明书的8个部分</p><p>说明书中可以有化学式、数学式。说明书附图，应附在说明书之后。</p><p>名称应表明或反映发明是产品还是方法，例如“高光催化活性二氧化钛的制备方法”。名称还应尽量反映出发明对象的用途或应用领域。</p><p>专利说明书是以具体的技术方案为主，理论说明可有可无。 </p><h1 id="单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。"><a href="#单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。" class="headerlink" title="单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。"></a>单目视觉SLAM方法在是否引入概率框架方面分为基于概率框架的方法和基于非概率框架的方法。其中前者的代表方法是基于Kalman滤波（KF）的方法，基于粒子滤波（PF）的方法等；后者的代表方法是基于关键帧和稀疏捆绑调整优化的方法，基于图优化的方法等。</h1>]]></content>
      
      
      
        <tags>
            
            <tag> 专利 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的内存对齐</title>
      <link href="/2019/06/14/C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
      <url>/2019/06/14/C-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>array &amp; string</title>
      <link href="/2019/06/13/array%20+%20string/"/>
      <url>/2019/06/13/array%20+%20string/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 724. <a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">Find Pivot Index</a></p><p>先求数组总和<code>sum</code>，然后维护一个当前数组之和 <code>cursum</code>, 然后用<code>sum</code> 减去 当前遍历到的元素，判断得到的结果是否等于2*cursum 。 </p><ul><li>等于 ， 当前位置即pivot</li><li>否则， 将当前数字加到cursum中， 继续for循环 遍历数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - nums[i] == <span class="number">2</span>*cursum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            cursum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-747-Largest-Number-At-Least-Twice-of-Others"><a href="#LeetCode-747-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="LeetCode 747. Largest Number At Least Twice of Others"></a>LeetCode 747. <a href="https://leetcode.com/problems/largest-number-at-least-twice-of-others/" target="_blank" rel="noopener">Largest Number At Least Twice of Others</a></h1><p>维护两个变量<em>maxn</em> 与 <em>sec</em> 分别记录数组的最大值和次大值 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dominantIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxn = INT_MIN, idx = <span class="number">-1</span>, sec = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; maxn) &#123;</span><br><span class="line">                sec = maxn;</span><br><span class="line">                maxn = nums[i];</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &gt; sec)&#123;</span><br><span class="line">                sec = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sec * <span class="number">2</span> &gt; maxn ? <span class="number">-1</span> : idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里 使用 INT_MIN或 INT_MAX 会 出现问题</p><h1 id="LeetCode-66-Plus-One"><a href="#LeetCode-66-Plus-One" class="headerlink" title="LeetCode 66. Plus One"></a>LeetCode 66. <a href="https://leetcode.com/problems/plus-one/" target="_blank" rel="noopener">Plus One</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; plusOne(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; digits) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = digits.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (digits[i]  != <span class="number">9</span>) &#123;</span><br><span class="line">                digits[i] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (digits[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            digits.insert(digits.begin(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> digits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="insert函数"><a href="#insert函数" class="headerlink" title="insert函数"></a>insert函数</h2><p>将元素插入到迭代器所指定的位置之前 （C++ primer P307）</p><h2 id="循环中break的使用"><a href="#循环中break的使用" class="headerlink" title="循环中break的使用"></a>循环中break的使用</h2><h1 id="LeetCode-498-Diagonal-Traverse"><a href="#LeetCode-498-Diagonal-Traverse" class="headerlink" title="LeetCode 498.Diagonal Traverse"></a>LeetCode 498.<a href="https://blog.csdn.net/liuchuo/article/details/54971290" target="_blank" rel="noopener">Diagonal Traverse</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-54-Spiral-Matrix"><a href="#LeetCode-54-Spiral-Matrix" class="headerlink" title="LeetCode 54.Spiral Matrix"></a>LeetCode 54.<a href="https://leetcode.com/problems/spiral-matrix/" target="_blank" rel="noopener">Spiral Matrix</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><h1 id="LeetCode-59-Spriral-Matrix-II"><a href="#LeetCode-59-Spriral-Matrix-II" class="headerlink" title="LeetCode 59.Spriral Matrix II"></a>LeetCode 59.<a href="https://leetcode.com/problems/spiral-matrix-ii/" target="_blank" rel="noopener">Spriral Matrix II</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//leetcode.com/problems/spiral-matrix-ii/discuss/22409/C%2B%2B-concise-solution.</span></span><br></pre></td></tr></table></figure><h1 id="LeeteCode-118-Pascal’s-Triangle"><a href="#LeeteCode-118-Pascal’s-Triangle" class="headerlink" title="LeeteCode 118. Pascal’s Triangle"></a>LeeteCode 118. <a href="https://leetcode.com/problems/pascals-triangle/" target="_blank" rel="noopener">Pascal’s Triangle</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array &amp; string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>array &amp; string</title>
      <link href="/2019/06/13/Backtracking/"/>
      <url>/2019/06/13/Backtracking/</url>
      
        <content type="html"><![CDATA[<p>LeetCode 724. <a href="https://leetcode.com/problems/find-pivot-index/" target="_blank" rel="noopener">Find Pivot Index</a></p><p>先求数组总和<code>sum</code>，然后维护一个当前数组之和 <code>cursum</code>, 然后用<code>sum</code> 减去 当前遍历到的元素，判断得到的结果是否等于2*cursum 。 </p><ul><li>等于 ， 当前位置即pivot</li><li>否则， 将当前数字加到cursum中， 继续for循环 遍历数组。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pivotIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cursum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sum - nums[i] == <span class="number">2</span>*cursum) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">            cursum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> array &amp; string </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XOR</title>
      <link href="/2019/06/11/XOR/"/>
      <url>/2019/06/11/XOR/</url>
      
        <content type="html"><![CDATA[<h1 id="Single-Number"><a href="#Single-Number" class="headerlink" title="Single Number"></a><a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1176" target="_blank" rel="noopener">Single Number</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span> <span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            result ^= num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>A better explanation why this technique works-</p><p>Let’s say we have an array - [2,1,4,5,2,4,1].<br>What we are doing is essentially this-</p><p>=&gt; 0 ^ 2 ^ 1 ^ 4 ^ 5 ^ 2 ^ 4 ^ 1</p><p>=&gt; 0^ 2^2 ^ 1^1 ^ 4^4 ^5 (Rearranging, taking same numbers together)</p><p>=&gt; 0 ^ 0 ^ 0 ^ 0 ^ 5</p><p>=&gt; 0 ^ 5</p><p>=&gt; 5 :)</p><h1 id="Intersection-of-Two-Arrays"><a href="#Intersection-of-Two-Arrays" class="headerlink" title="Intersection of Two Arrays"></a><a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1105" target="_blank" rel="noopener">Intersection of Two Arrays</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersection(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; myset(nums1.begin(), nums1.end());</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (myset.count(num2) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">                myset.erase(num2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用迭代器初始化set"><a href="#使用迭代器初始化set" class="headerlink" title="使用迭代器初始化set"></a>使用迭代器初始化set</h2><h2 id="从关联容器删除元素"><a href="#从关联容器删除元素" class="headerlink" title="从关联容器删除元素"></a>从关联容器删除元素</h2><p><code>c.erase(k)</code> 从c中删除每个关键字为k的元素。返回一个size_type值，指出删除元素的数量</p><h1 id="Happy-Number-https-leetcode-com-explore-learn-card-hash-table-183-combination-with-other-algorithms-1131"><a href="#Happy-Number-https-leetcode-com-explore-learn-card-hash-table-183-combination-with-other-algorithms-1131" class="headerlink" title="[Happy Number] (https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/)"></a>[Happy Number] (<a href="https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/" target="_blank" rel="noopener">https://leetcode.com/explore/learn/card/hash-table/183/combination-with-other-algorithms/1131/</a>)</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; path;<span class="comment">//I use the map to store the result of each calculation. if 19 is the key,the value is 82:1*1+9*9=82</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isHappy</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> value=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> key=n;</span><br><span class="line">        <span class="keyword">while</span> (n) &#123;<span class="comment">//calculate the value of the key.</span></span><br><span class="line">            <span class="keyword">int</span> temp = n%<span class="number">10</span>;</span><br><span class="line">            value+=temp*temp;</span><br><span class="line">            n/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (value==<span class="number">1</span>) &#123;<span class="comment">//if the value is 1,the key is a happy number.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (path.count(value) &gt; <span class="number">0</span>) &#123;<span class="comment">//if the value is already in the map,there is a cycle,so the key is not a happy number.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path[key]=value;<span class="comment">//put the key/value in the map</span></span><br><span class="line">        <span class="keyword">return</span> isHappy(value);<span class="comment">//calculate recursively</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 运算符 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>近日</title>
      <link href="/2019/06/11/%E8%BF%91%E6%97%A5/"/>
      <url>/2019/06/11/%E8%BF%91%E6%97%A5/</url>
      
        <content type="html"><![CDATA[<ul><li>leetcode 10题</li></ul><h1 id="size-与length-的区别"><a href="#size-与length-的区别" class="headerlink" title="size()与length()的区别"></a>size()与length()的区别</h1><p>C++中 二者没有区别， length()是因为沿用C语言习惯而保留下来的，string类最初只有length()，引入STL后，为了兼容又加入了size(),它是作为STL容器的属性存在的，便于用于STL算法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>subarry与subsequence</title>
      <link href="/2019/06/10/subarry%E4%B8%8Esubsequence/"/>
      <url>/2019/06/10/subarry%E4%B8%8Esubsequence/</url>
      
        <content type="html"><![CDATA[<p>subarray是截取数组中连续的一段子数组。(substring同理)</p><p>subsequence是序列中不连续的一段子序列。</p><p>[1,2,3,4,5,6]</p><p>subarray=[3,4,5];</p><p>subsequence=[2,4,5];</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>priority_queue</title>
      <link href="/2019/06/10/priority%20+%20queue/"/>
      <url>/2019/06/10/priority%20+%20queue/</url>
      
        <content type="html"><![CDATA[<h1 id="LeeteCode-347-Top-K-Frequent-Elements"><a href="#LeeteCode-347-Top-K-Frequent-Elements" class="headerlink" title="LeeteCode 347.Top K Frequent Elements"></a><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">LeeteCode 347.Top K Frequent Elements</a></h1><p>本题要注意的是语法上的东西: priority_queue 、pair</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; topKFrequent(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNum;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            mapNum[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; pq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : mapNum) &#123;</span><br><span class="line">            pq.push(&#123;num.second, num.first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k--) &#123;</span><br><span class="line">            result.push_back(pq.top().second);</span><br><span class="line">            pq.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="range-for-中-auto-后面要不要接-amp"><a href="#range-for-中-auto-后面要不要接-amp" class="headerlink" title="range for 中 auto 后面要不要接 &amp;"></a>range for 中 auto 后面要不要接 <code>&amp;</code></h2><p>如果需要修改容器中的元素，可以使用 <code>auto&amp;</code> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">    num *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面这段code是错误的，因为它向遍历的容器中添加了元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    nums.push_back(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能在范围for循环中向vector对象添加元素。<strong>但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加/删除元素</strong>。<em>reference</em>: 《C++ primer》 p99  p315  p316</p><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h3 id="first、second-是-pair-的-两个-public-数据成员"><a href="#first、second-是-pair-的-两个-public-数据成员" class="headerlink" title="first、second 是 pair 的 两个 public 数据成员"></a>first、second 是 pair 的 两个 public 数据成员</h3><h3 id="列表初始化"><a href="#列表初始化" class="headerlink" title="列表初始化"></a>列表初始化</h3><p>pair&lt;string, int&gt; author{“zhhp”, 1001};</p><h3 id="用make-pair生成pair对象"><a href="#用make-pair生成pair对象" class="headerlink" title="用make_pair生成pair对象"></a>用make_pair生成pair对象</h3><p>make_pair(v1, v2) 返回一个用v1, v2初始化的pair。 pair的类型从v1和v2的类型推断出来。</p>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> priority_queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hash</title>
      <link href="/2019/06/05/Hash/"/>
      <url>/2019/06/05/Hash/</url>
      
        <content type="html"><![CDATA[<p>unordered_map中不存在的值会被表示为 0 ， 下面这段代码输出为  2 3<br>                                                         0 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">hashmap.insert(make_pair(<span class="number">3</span>, <span class="number">2</span>));</span><br><span class="line">hashmap[<span class="number">1</span>] = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hashmap[<span class="number">3</span>] &lt;&lt;<span class="string">" "</span>&lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">hashmap.erase(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; hashmap[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span>&lt;&lt;hashmap[<span class="number">-1</span>] <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1.Two Sum"></a>LeetCode 1.<a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a></h1><h2 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h2><p>c.count(k) 返回关键字等于k的元素的数量，对于不允许重复关键字的容器，返回值永远是 0 或 1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; towSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.count([target - nums[i]]))</span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>c.find(k) 返回一个迭代器，指向第一个关键字为k的元素，若k不在容器中，则返回尾后迭代器</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Class Solution &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span> &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mapNums;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mapNums.find(target - nums[i]) != mapNums.end()) </span><br><span class="line">                <span class="keyword">return</span> &#123;mapNums[target - nums[i]], i&#125;;</span><br><span class="line">            mapNums[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-560-Subarray-Sum-Equals-K"><a href="#LeetCode-560-Subarray-Sum-Equals-K" class="headerlink" title="LeetCode 560. Subarray Sum Equals K"></a>LeetCode 560. <a href="https://leetcode.com/problems/subarray-sum-equals-k/" target="_blank" rel="noopener">Subarray Sum Equals K</a></h1><p>计算出从第一个数到每一个数的和，那么任意一段连续数字的和就可以通过两段和相减得出。<br>用sum表示从数组起始位置到当前位置所有数字的加和，用<code>Hash Table</code>来存储sum出现的次数，如果当前位置之前有和（prefix sum）为<code>sum - k</code>的位置，则这两个位置之间的数字之和为k。那么，以当前位置结尾，和为k的子数组个数为<code>hash[sum - k]</code>。遍历整个数组即可得出满足条件的子数组个数。<br><img src="//zhhp1001.github.io/2019/06/05/Hash/leet560.png" alt></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashNums;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="keyword">int</span> result;</span><br><span class="line">    hashNums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; num : nums) &#123;</span><br><span class="line">        sum += num;</span><br><span class="line">        <span class="keyword">if</span> (hashNums.count(sum - k))   <span class="comment">//这个if()可以提高近一半的效率</span></span><br><span class="line">            result += hashNums[sum - k];</span><br><span class="line">        hashNums[sum]++;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如下图所示，<code>if(hashNums.count(sum - k))</code> 对效率的提升是很惊人的<br><img src="//zhhp1001.github.io/2019/06/05/Hash/run.png" alt></p><p>LeetCode <a href="https://leetcode.com/problems/group-anagrams/" target="_blank" rel="noopener">49.Group Anagrams</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groupAnagrams(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; strs) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; mapStr;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; result;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> str : strs) &#123;</span><br><span class="line">            <span class="built_in">string</span> temp = str;</span><br><span class="line">            sort(temp.begin(), temp.end());</span><br><span class="line">            mapStr[temp].push_back(str);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : mapStr) &#123;</span><br><span class="line">            result.push_back(str.second);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="第一个for循环处"><a href="#第一个for循环处" class="headerlink" title="第一个for循环处"></a>第一个for循环处</h2><p>能自己写出类型来就不要用auto了</p><h2 id="unordered-map-第二个类型为vector容器时的情况"><a href="#unordered-map-第二个类型为vector容器时的情况" class="headerlink" title="unordered_map 第二个类型为vector容器时的情况"></a>unordered_map 第二个类型为vector容器时的情况</h2><h2 id="使用stl的-sort函数"><a href="#使用stl的-sort函数" class="headerlink" title="使用stl的 sort函数"></a>使用stl的 sort函数</h2><p>头文件<algorithm></algorithm></p><p>语法描述 sort(begin, end, cmp)  cmp参数可以没有， 默认为非降序排序。<br><strong>cmp:</strong></p><ul><li>升序： <code>less&lt;data-type&gt;</code></li><li>降序： <code>greater&lt;data-type&gt;</code><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">sort(a, a + <span class="number">5</span>, greater&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3.Longest Substring Without Repeating Characters"></a>LeetCode 3.<a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a></h1><h2 id="使用vector记录string中的字符是否重复"><a href="#使用vector记录string中的字符是否重复" class="headerlink" title="使用vector记录string中的字符是否重复"></a>使用vector记录string中的字符是否重复</h2><p>当 <code>dict[s[i]] &gt; start</code>时，说明在dict中 s[i]这个字符对应的索引已经被改变过， 即出现了重复的字符， 此时我们让start指向第一个重复的字符处。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dict(<span class="number">256</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dict[s[i]] &gt; start ) &#123;</span><br><span class="line">                start = dict[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            dict[s[i]] = i;</span><br><span class="line">            maxlen = max (i - start, maxlen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxlen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用unordered-map-代替上面的-定长数组"><a href="#使用unordered-map-代替上面的-定长数组" class="headerlink" title="使用unordered_map 代替上面的 定长数组"></a>使用unordered_map 代替上面的 定长数组</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; charMap;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (charMap.count(s[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                start = max(start, charMap[s[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">            charMap[s[i]] = i;</span><br><span class="line">            maxLen = max(maxLen, i-start);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="LeetCode-205-Isomorphic-Strings"><a href="#LeetCode-205-Isomorphic-Strings" class="headerlink" title="LeetCode 205. Isomorphic Strings"></a>LeetCode 205. <a href="https://leetcode.com/problems/isomorphic-strings/" target="_blank" rel="noopener">Isomorphic Strings</a></h1><p>同构字符串。我们用两个哈希表分别来记录两个字符串中字符出现的情况，由于ASCII只有256个字符，所以我们用一个大小为256的数组来代替哈希表，并初始化为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> b[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[s[i]] != b[t[i]]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            b[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>把上面的数组换成stl中的哈希表也是一样的（unordered_map&lt;char, int&gt;）。<br>这段代码的精髓在于 <code>a[s[i]] = i + 1;</code> 和 <code>b[t[i]] = i + 1;</code> ， 这里i + 1 相当于让不同位置的字符有不同的索引，避免了将<em>aba</em>, <em>baa</em>这样的string误判为同构。</p><h1 id="LeetCode-Minimum-Index-Sum-of-Two-Lists"><a href="#LeetCode-Minimum-Index-Sum-of-Two-Lists" class="headerlink" title="LeetCode Minimum Index Sum of Two Lists"></a>LeetCode <a href="https://leetcode.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">Minimum Index Sum of Two Lists</a></h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; findRestaurant(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list1, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; list2) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; result;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list1.size(); i++) &#123;</span><br><span class="line">            hashmap[list1[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list2.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.count(list2[i]) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (min &gt; i + hashmap[list2[i]]) &#123;</span><br><span class="line">                    min = i + hashmap[list2[i]];</span><br><span class="line">                    result.clear();</span><br><span class="line">                    result.push_back(list2[i]);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (min == i + hashmap[list2[i]]) &#123;</span><br><span class="line">                    result.push_back(list2[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="clear-清空所有元素"><a href="#clear-清空所有元素" class="headerlink" title="clear() 清空所有元素"></a>clear() 清空所有元素</h2><h2 id="C-C-整型的上下限-INT-MAX-INT-MIN"><a href="#C-C-整型的上下限-INT-MAX-INT-MIN" class="headerlink" title="C/C++ 整型的上下限 INT_MAX INT_MIN"></a>C/C++ 整型的上下限 INT_MAX INT_MIN</h2><p>int 占 4字节 32位， 因此：<br>INT_MAX = 2<sup>31</sup> - 1<br>INT_MIN = -2<sup>31</sup></p><p>Leetcode 349.<a href="https://leetcode.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">Intersection of Two Arrays</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; intersect(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num1 : nums1) &#123;</span><br><span class="line">            hashmap[num1]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num2 : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap[num2] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                result.push_back(num2);</span><br><span class="line">                hashmap[num2]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>第二个for循环处 if(hashmap[num2] &gt; 0) 不可以替换成 hashmap.count(num2)。 因为<code>count(key)</code>函数是用以统计key在unordered_map中出现的次数，而unordered_map不允许存在重复的key，因此，如果key存在，则count(key) 返回 1， 否则 返回 0。 这里我犯的错误属于 对count(key) 功能的 认知错误。</p><h1 id="LeetCode-219-Contains-Duplicate-II"><a href="#LeetCode-219-Contains-Duplicate-II" class="headerlink" title="LeetCode 219.Contains Duplicate II"></a>LeetCode 219.<a href="https://leetcode.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">Contains Duplicate II</a></h1><p>此题错在读题不仔细， 没有意识到<em>at most</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (hashmap.count(nums[i]) ) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((i - hashmap[nums[i]]) &lt;= k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            hashmap[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -数据结构与算法-unordered_map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历（C++实现）</title>
      <link href="/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
      <url>/2019/06/04/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88C-%E5%AE%9E%E7%8E%B0%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="定义二叉树结点类"><a href="#定义二叉树结点类" class="headerlink" title="定义二叉树结点类"></a>定义二叉树结点类</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    BnaryTreeNode* lc;</span><br><span class="line">    BinaryTreeNode* rc;</span><br><span class="line">    BinaryTreeNode (<span class="keyword">int</span> cont&amp; _val, BinaryTreeNode* _lc = <span class="literal">nullptr</span>, BinaryTreeNode* _rc = <span class="literal">nullptr</span>) : </span><br><span class="line">    val(_val), lc(_lc), rc(_rc) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先序遍历、中序遍历、后序遍历<strong>访问节点</strong>的顺序是一致的， 不同之处在于处理节点的顺序。有的遍历流程把访问到的节点暂存起来，达成某种条件后再对其进行处理（比如输出），我们约定，根节点V、左孩子L、右孩子R，那么遍历顺序可以记为：</p><ul><li>先序遍历VLR：到达一个节点后，即刻输出该节点的值，并继续遍历其左、右子树。</li><li>中序遍历LVR：到达一个节点后，先将该节点暂存，遍历完其左子树后，再输出该节点的值，然后遍历其右子树。</li><li>后序遍历LRV： 到达一个节点后，先将该节点暂存，遍历完其左右子树后，再输出该节点的值。</li></ul><h1 id="C-实现"><a href="#C-实现" class="headerlink" title="C++实现"></a>C++实现</h1><h2 id="先序遍历（VLR）"><a href="#先序遍历（VLR）" class="headerlink" title="先序遍历（VLR）"></a>先序遍历（VLR）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pre_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>与先序遍历类似，唯一区别是到达该节点时，并不直接输出该节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">in_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            stackNode.pop();</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">            root = root-&gt;rc;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>后序遍历在决定是否可以输出当前节点的值的时候，需要考虑其左右子树是否都已遍历完成。 因此， 我们需要设置一个<strong>lastvisit指针</strong>，若lastvisit指向当前节点的右孩子，表示该节点的左右子树都已遍历完成，可以输出当前节点 （否则，继续探索当前节点的右子树）， 并使lastvisit指向当前节点， 将当前节点（指针）设置为空（这样，下一轮循环就可以访问栈顶元素）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">post_traversal</span> <span class="params">(BinaryTreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;BinaryTreeNode*&gt; stackNode;</span><br><span class="line">    BinaryTreeNode* lastvisit = root;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stackNode.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            stackNode.push(root);</span><br><span class="line">            root = root-&gt;lc;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            root = stackNode.top();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;rc == <span class="literal">nullptr</span> || root-&gt;rc == lastvisit) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; root-&gt;val &lt;&lt;<span class="string">" "</span>;</span><br><span class="line">                stackNode.pop();</span><br><span class="line">                lastvisit = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                root = root-&gt;rc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DSA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
