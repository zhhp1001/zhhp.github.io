<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">










  <meta name="google-site-verification" content="vixuolpre3z1X0Rw_WgvaiNOzbq7uxD0g6uQRH56Pow">









  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">







<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: true,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="https://blog.csdn.net/u012414189/article/details/83856874 C++语言基础1. 指针和引用的区别C++之父：我为啥引入引用 “引用是别名”这个概念仅仅只是在语言级别上，深入底层的话，引用必定需要存储绑定的对象的地址信息的，所以肯定会占内存。 （引用只是一个概念，怎么实现，由编译器决定，一般实现为const指针）  引用并非对象，它只是为一个已">
<meta name="keywords" content="面试">
<meta property="og:type" content="article">
<meta property="og:title" content="面试总结">
<meta property="og:url" content="http://zhhp1001.github.io/2019/07/31/面试总结/index.html">
<meta property="og:site_name" content="汐">
<meta property="og:description" content="https://blog.csdn.net/u012414189/article/details/83856874 C++语言基础1. 指针和引用的区别C++之父：我为啥引入引用 “引用是别名”这个概念仅仅只是在语言级别上，深入底层的话，引用必定需要存储绑定的对象的地址信息的，所以肯定会占内存。 （引用只是一个概念，怎么实现，由编译器决定，一般实现为const指针）  引用并非对象，它只是为一个已">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://zhhp1001.github.io/2019/07/31/面试总结/1.png">
<meta property="og:image" content="http://zhhp1001.github.io/2019/07/31/面试总结/2.png">
<meta property="og:updated_time" content="2019-09-06T11:33:48.395Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试总结">
<meta name="twitter:description" content="https://blog.csdn.net/u012414189/article/details/83856874 C++语言基础1. 指针和引用的区别C++之父：我为啥引入引用 “引用是别名”这个概念仅仅只是在语言级别上，深入底层的话，引用必定需要存储绑定的对象的地址信息的，所以肯定会占内存。 （引用只是一个概念，怎么实现，由编译器决定，一般实现为const指针）  引用并非对象，它只是为一个已">
<meta name="twitter:image" content="http://zhhp1001.github.io/2019/07/31/面试总结/1.png">





  
  
  <link rel="canonical" href="http://zhhp1001.github.io/2019/07/31/面试总结/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>面试总结 | 汐</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">汐</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">江山风月， 本无常主</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    
   
  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zhhp1001.github.io/2019/07/31/面试总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhhp">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="汐">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">面试总结

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-31 11:12:58" itemprop="dateCreated datePublished" datetime="2019-07-31T11:12:58+08:00">2019-07-31</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-09-06 19:33:48" itemprop="dateModified" datetime="2019-09-06T19:33:48+08:00">2019-09-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
            
              
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
            
                <span class="post-meta-item-text">评论数：</span>
                <a href="/2019/07/31/面试总结/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/31/面试总结/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
            <span id="/2019/07/31/面试总结/" class="leancloud_visitors" data-flag-title="面试总结">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              
                <span class="post-meta-item-text">阅读次数：</span>
              
                <span class="leancloud-visitors-count"></span>
            </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="https://blog.csdn.net/u012414189/article/details/83856874" target="_blank" rel="noopener">https://blog.csdn.net/u012414189/article/details/83856874</a></p>
<h1 id="C-语言基础"><a href="#C-语言基础" class="headerlink" title="C++语言基础"></a>C++语言基础</h1><h2 id="1-指针和引用的区别"><a href="#1-指针和引用的区别" class="headerlink" title="1. 指针和引用的区别"></a>1. 指针和引用的区别</h2><p>C++之父：我为啥引入引用<br><img src="//zhhp1001.github.io/2019/07/31/面试总结/1.png" alt></p>
<p>“引用是别名”这个概念仅仅只是在语言级别上，深入底层的话，引用必定需要存储绑定的对象的地址信息的，所以肯定会占内存。 （引用只是一个概念，怎么实现，由编译器决定，一般实现为const指针）</p>
<ul>
<li>引用并非对象，它只是为一个已经存在的对象所起的别名。 指针本身就是一个对象。</li>
<li>因此不能定义引用的引用（多级引用）， 但是可以使用多级指针（int** p）。</li>
<li>reference必须绑定某个对象，没有所谓null reference，因此必须在定义时赋初值。 指针可以为空，无须在定义时赋初值（在块作用域内定义的指针如果没有被初始化，将拥有一个不确定的值）。</li>
<li>sizeof引用 得到的是所绑定对象的大小， sizeof指针 得到的是计算机的字长（word size ， 32位/64位， 4字节/8字节）</li>
</ul>
<h2 id="2-堆和栈的区别"><a href="#2-堆和栈的区别" class="headerlink" title="2. 堆和栈的区别"></a>2. 堆和栈的区别</h2><p>1.申请方式： 堆是程序员申请，栈是系统自动分配<br>2.系统响应： 栈： 只要栈的剩余空间大于所申请的空间，系统就会为程序提供内存，否则栈溢出；<br>            堆： 堆分配算法。。。<br>3.空间大小： 堆是不连续的区域，空间很大，上限取决于有效的虚拟内存； 栈是一块连续的区域，大小一般是1-2M<br>4.生长方向： 堆向上生长， 栈向下生长（高地址向低地址）<br>5.分配方式： 堆是动态分配的。<br>6.分配效率： 栈是系统底层数据结构，效率比较高，堆是C++函数库提供的，效率低<br>7.碎片问题： 栈内存是连续的，而堆在多次new和delete后会产生很多碎片</p>
<h2 id="3-new和delete是如何实现的，new-与-malloc的异同处"><a href="#3-new和delete是如何实现的，new-与-malloc的异同处" class="headerlink" title="3. new和delete是如何实现的，new 与 malloc的异同处"></a>3. new和delete是如何实现的，new 与 malloc的异同处</h2><ol start="0">
<li>属性</li>
</ol>
<p>new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持。</p>
<ol>
<li>参数</li>
</ol>
<p>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</p>
<ol start="2">
<li>返回类型</li>
</ol>
<p>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。</p>
<ol start="3">
<li>分配失败</li>
</ol>
<p>new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。</p>
<ol start="4">
<li><p>自定义类型</p>
<p> new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。</p>
<p> malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。</p>
</li>
<li><p>重载</p>
</li>
</ol>
<p>C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。</p>
<ol start="6">
<li>内存区域</li>
</ol>
<p>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</p>
<p>malloc/free与new/delete异同点</p>
<p>相同点<br>malloc/free与new/delete都可以用于申请动态内存和释放内存，他们申请的空间都在堆上分配。</p>
<p>不同点<br>1）操作对象不同<br>malloc/free是C++/C语言的标准库文件，new/delete是C++的运算符；<br>对非内部数据对象，malloc/free无法满足动态对象要求。对象在创建时要自动执行构造函数，对象消亡之前要自动执行析构函数，而malloc/free是库函数，不是运算符，故不在编译器控制权限之内，不能够将执行构造函数和析构函数强加于malloc/free身上。而由于new/delete是C++语言，能够完成动态内存分配和初始化工作，并能够完成清理与释放内存工作，即能够自动执行构造函数和析构函数；</p>
<p>2）用法不同<br>malloc分配内存空间前需要计算分配内存大小；而new能够自动分配内存空间；<br>malloc是底层函数，其函数返回值类型为void *；而new运算符调用无参构造函数，故返回值为对应对象的指针；<br>malloc函数类型不是安全的，编译器不对其进行类型转换、类型安全的相关检查。malloc申请空间后，不会对其初始化，要单独初始化；而new类型是安全的，因为它内置了sizeof、类型转换和类型安全检查功能，且在创建对象时，就完成了初始化工作，一般初始化调用无参构造函数；</p>
<p>operator new对应于malloc，且operator new可以重载，可以自定义内存分配策略，甚至不做内存分配，甚至分配到非内存设备上；但malloc不能。</p>
<p>free只进行释放空间；而delete则释放空间的同时调用析构函数。<br>此外delete使用是注意释放数组的方法为delete []数组名。</p>
<p>联系</p>
<h2 id="new和delete功能覆盖了malloc-free，但因C-程序常会用到C函数，而C函数只能使用malloc-free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。"><a href="#new和delete功能覆盖了malloc-free，但因C-程序常会用到C函数，而C函数只能使用malloc-free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。" class="headerlink" title="new和delete功能覆盖了malloc/free，但因C++程序常会用到C函数，而C函数只能使用malloc/free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。"></a>new和delete功能覆盖了malloc/free，但因C++程序常会用到C函数，而C函数只能使用malloc/free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。</h2><p>作者：祚儿疯<br>来源：CSDN<br>原文：<a href="https://blog.csdn.net/u012414189/article/details/83856874" target="_blank" rel="noopener">https://blog.csdn.net/u012414189/article/details/83856874</a><br>版权声明：本文为博主原创文章，转载请附上博文链接！</p>
<h2 id="4-C和C-的区别"><a href="#4-C和C-的区别" class="headerlink" title="4. C和C++的区别"></a>4. C和C++的区别</h2><p>C 是面向过程的一门编程语言，C++ 可以很好地进行面向对象的程序设计。C++ 虽然主要是以 C 的基础发展起来的一门新语言，但它不是 C 的替代品，它们是兄弟关系。面向对象和面向过程不是矛盾的，而是各有用途、互为补充的。<br>C++ 对 C 的增强，表现在六个方面：</p>
<ul>
<li>增强了类型检查机制</li>
<li>增加了面向对象的机制</li>
<li>增加了泛型编程的机制（template）</li>
<li>增加了异常处理</li>
<li>增加了重载的机制</li>
<li>增加了标准模板库（STL）<h3 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h3>C/C++ 是静态数据类型语言，类型检查发生在编译时，因此编译器知道程序中每一个变量对应的数据类型。C++ 的类型检查相对更严格一些。<br>很多时候需要一种能够实际表示多种类型的数据类型。传统上 C 使用 void* 指针指向不同对象，使用时强制转换回原始类型或兼容类型。这样做的缺陷是绕过了编译器的类型检查，如果错误转换了类型并使用，会造成程序崩溃等严重问题。<br>C++ 通过使用基类指针或引用来代替 void* 的使用，避免了这个问题（其实也是体现了类继承的多态性）。<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3>C 的结构体传递的是一种数据结构，我们只是在主函数里面对这种数据类型做某种调用。主函数的架构依然是基于函数、函数族的处理过程，即面向过程。<br>C++ 中最大的区别就是允许在结构体中封装函数，而在其他的地方直接调用这个函数。这个封装好的可直接调用的模块有个新名词——对象；并且也把结构体换一个名字——类。这就是面向对象的思想。在构建对象的时候，把对象的一些操作全部定义好并且给出接口的方式，对于外部使用者而言，可以不需要知道函数的处理过程，只需要知道调用方式、传递参数、返回值、处理结果。<h3 id="泛型编程（template）"><a href="#泛型编程（template）" class="headerlink" title="泛型编程（template）"></a>泛型编程（template）</h3>所谓泛型编程，简而言之就是不同的类型采用相同的方式来操作。在 C++ 的使用过程中，直接 template 用的不多，但是用 template 写的库是不可能不用的。因此需要对泛型有比较深入的了解，才可以更好地使用这些库。<br>C++ 里面的模版技术具有比类、函数更高的抽象水平，因为模版能够生成出（实例化）类和函数。可以用来：<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3>C 语言不提供对错误处理的直接支持，但它以返回值的形式允许程序员访问底层数据。在发生错误时，大多数的 C 或 UNIX 函数调用返回 1 或 NULL，同时会设置一个错误代码 errno，该错误代码是全局变量，表示在函数调用期间发生了错误。可以在 errno.h 头文件中找到各种各样的错误代码。<br>所以，C 程序员可以通过检查返回值，然后根据返回值决定采取哪种适当的动作。开发人员应该在程序初始化时，把 errno 设置为 0（表示没有错误），这是一种良好的编程习惯。<br>C++ 提供了一系列标准的异常，定义在 <exception> 中，我们可以在程序中使用这些标准的异常。<h3 id="函数重载-amp-运算符重载"><a href="#函数重载-amp-运算符重载" class="headerlink" title="函数重载 &amp; 运算符重载"></a>函数重载 &amp; 运算符重载</h3>C++ 可以实现函数重载，条件是：函数名必须相同，返回值类型也必须相同，但参数的个数、类型或顺序至少有其一不同。<br>重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。大多数的重载运算符可被定义为普通的非成员函数（func(a, b) 形式调用）或者被定义为类成员函数（a.func(b) 形式调用）。<h3 id="标准模板库（STL）"><a href="#标准模板库（STL）" class="headerlink" title="标准模板库（STL）"></a>标准模板库（STL）</h3></exception></li>
</ul>
<h2 id="5-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><a href="#5-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）" class="headerlink" title="5. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"></a>5. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h2><p>两者都是面向对象的语言，两者都能实现面向对象的核心思想（封装、继承、多态）。但是由于c++为了兼容c语言，java不兼容C，它是一种完全的面向对象语言。</p>
<p>区别：<br>语言特性：<br>1.指针：c++有指针来访问内存，而JAVA中对于用户态，编程者无法找到指针来直接访问内存指针，只有限定版的引用，更加安全。<br>2.多重继承：c++支持多重继承，可以继承多个父类。JAVA不支持多重继承，但是允许一个类继承多个接口。<br>3.数据类型和类：Java是完全面向对象的语言，所有函数和变量都必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。对象将数据和方法结合起来，把它们封装在类中，这样每个对象都可实现自己的特点和行为。而c++允许将函数和变量定义为全局的。<br>4.自动内存管理：java内存支持自动对无用内存回收管理，c++需要人为的使用delete去释放内存。<br>5.c++支持操作符重载，但是java不支持操作符重载</p>
<p>垃圾回收：<br>java内存支持自动对无用内存回收管理，c++需要人为的使用delete去释放内存。</p>
<p>应用场景：<br>C++相对于java来看是偏底层的语言，应用场景也是一些偏底层的软件，例如：图像，客户端，桌面软件等。<br>JAVA则是偏向应用的语言，相对来说，生态圈较好，有一些高级特性也比较好用，一般是上层应用软件，例如移动设备的软件，web网页后台逻辑开发等等。</p>
<h2 id="6-Struct和class的区别"><a href="#6-Struct和class的区别" class="headerlink" title="6. Struct和class的区别"></a>6. Struct和class的区别</h2><p>C++中class和struct的<strong>访问控制权限</strong>不同，class默认private struct默认为public<br>继承：class继承默认是private继承，而struct继承默认是public继承</p>
<h2 id="7-define-和const的区别（编译阶段、安全性、内存占用等）"><a href="#7-define-和const的区别（编译阶段、安全性、内存占用等）" class="headerlink" title="7. define 和const的区别（编译阶段、安全性、内存占用等）"></a>7. define 和const的区别（编译阶段、安全性、内存占用等）</h2><p>编译阶段： define是预编译阶段展开，而const是在运行阶段使用<br>安全性： const常量是有数据类型的，那么编译器会对const变量的类型等安全性进行检查，但是define只是在预编译阶段展开，不会进行类型的安全检查，替换时可能产生错误。<br>内存占用： define不会占用内存，单纯的替换而已， const会占用内存，会有对应的内存地址。</p>
<h2 id="8-在C-中const和static的用法（定义，用途）"><a href="#8-在C-中const和static的用法（定义，用途）" class="headerlink" title="8. 在C++中const和static的用法（定义，用途）"></a>8. 在C++中const和static的用法（定义，用途）</h2><p>const成员也不能在类定义处初始化，只能通过构造函数初始化列表进行，并且必须有构造函数。<br>const数据成员只在某个对象的生存期内是常量，而对于整个类而言却是可变的。因为类可以创建多个对象，不同对象其const数据成员的值可以不同。所以不能在类的声明中初始化const数据成员，因为类的对象没被创建时，编译器不知道const数据成员的值是什么。<br>const数据成员的初始化只能在构造函数的初始化列表中进行。要想建立在整个类中都恒定的常量，应该用类中的枚举常量来实现，或者’static const’</p>
<p>static表示的是静态的。类的静态成员函数、静态成员变量是和类相关的，而不是和类的具体对象相关的。即使没有具体对象，也能调用类的静态成员函数和成员变量。一般类的静态函数几乎就是一个全局函数，只不过它的作用域限于包含它的文件中。</p>
<p>在C++中，static静态成员变量不能在类的内部初始化。在类的内部只是声明，定义必须在类定义体的外部，通常在类的实现文件中初始化。如：double Account::Rate = 2.5; static 关键字只能用于类定义体内部的声明中，定义时不能表示为static。<br>用途：<br>const成员函数主要目的是防止成员函数修改对象的内容，即const成员函数不能修改成员变量的值，但可以访问成员变量。<br>static成员函数主要目的是作为类作用域的全局函数。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1.不能直接存取类的非静态成员变量，调用非静态成员函数2.不能被声明为virtual。</p>
<h2 id="9-const和static在类中使用的注意事项（定义、初始化和使用）"><a href="#9-const和static在类中使用的注意事项（定义、初始化和使用）" class="headerlink" title="9. const和static在类中使用的注意事项（定义、初始化和使用）"></a>9. const和static在类中使用的注意事项（定义、初始化和使用）</h2><p>定义： const可以在类内部定义，但是定义的位置不能初始化；static只能在类的内部声明，定义只能在类的外部，并且定义的时候不能加static关键字。(C++11开始允许静态成员变量在类内定义并初始化)<br>初始化： const只能在类的构造函数的初始化列表中初始化；static初始化不能在类内部初始化，必须在类外部初始化。<br>用途：<br>const成员函数主要目的是防止成员函数修改对象的内容，即const成员函数不能修改成员变量的值，但可以访问成员变量。<br>static成员函数主要目的是作为<strong>类作用域的全局函数</strong>。不能访问类的非静态数据成员。类的静态成员函数没有this指针，这导致：1.不能直接存取类的非静态成员变量，调用非静态成员函数2.不能被声明为virtual。</p>
<h2 id="10-C-中的const类成员函数（用法和意义）"><a href="#10-C-中的const类成员函数（用法和意义）" class="headerlink" title="10. C++中的const类成员函数（用法和意义）"></a>10. C++中的const类成员函数（用法和意义）</h2><ol>
<li><code>void func() const;</code><br>表明是常量成员函数，这个const表明这个函数不会改变数据成员的值。</li>
<li><code>void func(const a) const;</code><br>表明是参数是常量的常量成员函数，接收的参数是常量，同时不能修改数据成员的值。</li>
</ol>
<p>意义： 为什么这么做？<br>这是为了保证它能被const常量对象调用，我们知道，在定义一个对象或者一个变量时，如果在类型前加一个const,如const int x；则表示定义了一个常量，它的值不能被修改。但是创建的对象却可以调用成员函数，调用的成员函数很可能改变对象的值。所以这个时候const类成员函数就出现了。<br>我们把那些肯定不会修改对象的各个属性值的成员函数加上const说明符，这样，在编译时，编译器将对这些const成员函数进行检查，如果确实没有修改对象值的行为，则检查通过，之后，如果一个const常对象调用这些const成员函数，编译器将允许。</p>
<h2 id="11-计算下面几个类的大小："><a href="#11-计算下面几个类的大小：" class="headerlink" title="11.  计算下面几个类的大小："></a>11.  计算下面几个类的大小：</h2><p>class A {};: sizeof(A) = 1;<br>class A { virtual Fun(){} };: sizeof(A) = 4(32位机器)/8(64位机器);<br>class A { static int a; };: sizeof(A) = 1;<br>class A { int a; };: sizeof(A) = 4;<br>class A { static int a; int b; };: sizeof(A) = 4;<br>1.确切地说，类只是一个类型定义，它是没有大小可言的。用sizeof运算符对一个类型名操作，得到的是具有该类型 实体的大小。<br>2.一个对象的大小等于所有<strong>非静态成员</strong>大小的总和，大于的部分是编译器自主添加的。<br>C++标准规定类的大小不为0，空类的大小为1，当类不包含虚函数和非静态数据成员时，其对象大小也为1.如果在类中声明了虚函数（不管是一个还是多个），在实例化对象时，编译器会自动在对象里安插一个指针指向虚函数表。而虚函数本身和其他成员函数一样，不占用对象的空间。</p>
<h2 id="12-给一个代码，求输出结果"><a href="#12-给一个代码，求输出结果" class="headerlink" title="12. 给一个代码，求输出结果"></a>12. 给一个代码，求输出结果</h2><p>class A<br>{
public:<br>A(int x){}<br>}
问：A a = 1;是否正确, 如果正确, 那么它调用了哪些函数？<br>这类题目更常见的是在基类和子类有不同实现方法。（虚函数相关，栗子很多，不多说了）</p>
<p>正确。 由于A没有显示的声明，所以可以用int型进行强制转换，编译器碰到这种情况，首先如果是没有优化的编译器，对1进行强制转换int型，然后调用默认的赋值函数，1赋值给x，然后调用构造函数构造。其次，如果是有优化的编译器，可以将1强制转换成A类型，调用一次构造函数，然后再调用默认赋值构造函数赋值给a。</p>
<h2 id="13-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><a href="#13-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等" class="headerlink" title="13.  C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"></a>13.  C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h2><p>STL是一个c++里面非常强大的库，c11引进的，里面封装例如容器，泛型算法等。</p>
<h2 id="14-STL源码中的hash表的实现"><a href="#14-STL源码中的hash表的实现" class="headerlink" title="14.  STL源码中的hash表的实现"></a>14.  STL源码中的hash表的实现</h2><p>hash_table是STL中hash_map 和 hash_set 的内部数据结构，hash_table的插入/删除/查找的时间复杂度都为O(1),是查找速度最快的一种数据结构，但是hash_table中的数据是无序的，一般也只有在数据不需要排序，只需要满足快速查找/插入/删除的时候使用hash_table。</p>
<h2 id="15-STL中unordered-map和map的区别"><a href="#15-STL中unordered-map和map的区别" class="headerlink" title="15. STL中unordered_map和map的区别"></a>15. STL中unordered_map和map的区别</h2><p>map是一种映射，这种映射是有序的，底层是使用红黑树来完成的，数据通过键值才存储，键是唯一的。<br>unordered_map，是一种无序的，底层是通过hash表来完成的。unordered库使用“桶”来存储元素，散列值相同的被存储在一个桶里。当散列容器中有大量数据时，同一个桶里的数据也会增多，造成访问冲突，降低性能。为了提高散列容器的性能，unordered库会在插入元素是自动增加桶的数量，不需要用户指定。每个桶都是用list来完成的。<br>map<br>优点： </p>
<ul>
<li>有序性： 其元素的有序性再很多应用中都会简化很多操作。</li>
<li>红黑树： 内部实现一个红黑树使得map的很多操作在lgn的时间复杂度下就可以实现，因此效率很高。<br>缺点：</li>
<li>空间占用率高，每一个节点都需要额外保存父节点，孩子节点以及红黑性质，使得每一个节点都会占用大量的空间。<br>适用于： 对顺序有要求的问题。<br>unordered_map<br>优点： 由于使用了哈希表，因此查找速度非常快。<br>缺点： 哈希表的建立比较耗费时间<br>适用于： 查找问题<h2 id="16-STL中vector的实现"><a href="#16-STL中vector的实现" class="headerlink" title="16. STL中vector的实现"></a>16. STL中vector的实现</h2>注意两个点：</li>
</ul>
<p>1.vector有备用空间，当备用空间不够的时候，会重新开辟原空间两倍的空间进行重写分配。<br>2.vector支持随机的存取，但是最好是选择从末尾插入，因为从中间插入会导致元素的移动，带来了性能的开销。</p>
<h2 id="17-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><a href="#17-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。" class="headerlink" title="17. vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。"></a>17. vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h2><p>vector压入容器的对象都是拷贝操作，而且vector的数据存放都是连续存储的，所以在操作vector操作时，应该尽量避免对尾部操作之后的地方插入删除操作，因为这样会造成元素的移动，造成大量的开销。</p>
<p>频繁对vector调用push_back()会导致性能下降，这是由于系统每次给vector分配固定大小的空间，这个空间可能比用户想分配的空间大一些，但是频繁的使用push_back向容器中插入元素，会导致内存分配空间不够，会再次将整个对象的存储空间重新分配，将旧的元素移动到新的空间中，开销是非常大的。</p>
<h2 id="18-C-中的重载和重写的区别"><a href="#18-C-中的重载和重写的区别" class="headerlink" title="18. C++中的重载和重写的区别"></a>18. C++中的重载和重写的区别</h2><p><a href="https://blog.csdn.net/xu1105775448/article/details/80118159" target="_blank" rel="noopener">https://blog.csdn.net/xu1105775448/article/details/80118159</a><br>重载：</p>
<p>1.在同一个作用域下，函数名相同，函数的参数不同（参数不同指参数的类型或参数的个数不相同）<br>2.不能根据返回值判断两个函数是否构成重载。<br>3.当函数构成重载后，调用该函数时，编译器会根据函数的参数选择合适的函数进行调用。</p>
<p>重定义（隐藏）<br>1.在不同的作用域下（这里不同的作用域指一个在子类，一个在父类 ），函数名相同的两个函数构成重定义。<br>2.当两个函数构成重定义时，父类的同名函数会被隐藏，当用子类的对象调用同名的函数时，如果不指定类作用符，就只会调用子类的同名函数。<br>3.如果想要调用父类的同名函数，就必须指定父类的域作用符。</p>
<p>重写<br>也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。</p>
<h2 id="19-C-内存管理（热门问题）"><a href="#19-C-内存管理（热门问题）" class="headerlink" title="19. C ++内存管理（热门问题）"></a>19. C ++内存管理（热门问题）</h2><p>c++的内存管理延续c语言的内存管理，但是也增加了其他的，例如智能指针，除了常见的堆栈的内存管理之外，c++支持智能指针，智能指针的对象进行赋值拷贝等操作的时候，每个智能指针都有一个关联的计数器，该计数器记录共享该对象的指针个数，当最后一个指针被销毁的时候，计数器为0,会自动调用析构函数来销毁函数。</p>
<h2 id="20-介绍面向对象的三大特性，并且举例说明每一个。"><a href="#20-介绍面向对象的三大特性，并且举例说明每一个。" class="headerlink" title="20. 介绍面向对象的三大特性，并且举例说明每一个。"></a>20. 介绍面向对象的三大特性，并且举例说明每一个。</h2><p>面向对象的三大特性：封装、继承、多态。</p>
<p>封装：将很多有相似特性的内容封装在一个类中，例如学生的成绩学号、课程这些可以封装在同一个类中；</p>
<p>继承：某些相似的特性，可以从一个类继承到另一个类，类似生活中的继承，例如有个所有的汽车都有4个轮子，那么我们在父类中定义4个轮子，通过继承获得4个轮子的功能，不用再类里面再去定义这4个轮子的功能。</p>
<p>多态：多态指的相同的功能，不同的状态，多态在面向对象c++里面是通过重载和覆盖来完成的，覆盖在c++里面通过虚函数来完成的。例如鸭子的例子，所有的鸭子都有颜色，我们可以将这个颜色设置成为一个虚函数，通过继承子类对虚函数进行覆盖，不同子类中有各自的颜色，也就是有各自不同的鸭子颜色，这就是多态的典型表现之一。</p>
<h2 id="21-多态的实现（和下个问题一起回答）"><a href="#21-多态的实现（和下个问题一起回答）" class="headerlink" title="21. 多态的实现（和下个问题一起回答）"></a>21. 多态的实现（和下个问题一起回答）</h2><h2 id="22-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><a href="#22-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）" class="headerlink" title="22. C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"></a>22. C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h2><p>多态通过覆盖和重载来完成。</p>
<p>虚函数分为两种，纯虚函数和虚函数，纯虚函数适用于抽象基类，不需要定义，类似一种接口，是多态的典型处理方式。</p>
<p>一个类如果定义了虚函数，那么编译器会自动为它加上一个虚函数表，并提供一个指向虚函数表的指针，子类通过继承，可以覆盖父类的虚函数，当用户调用虚函数的时候，会调用指针，去虚函数表中找匹配的虚函数，如果当前对象有覆盖的虚函数，则去执行覆盖的虚函数，否则执行父类的虚函数。</p>
<h2 id="23-实现编译器处理虚函数表应该如何处理"><a href="#23-实现编译器处理虚函数表应该如何处理" class="headerlink" title="23. 实现编译器处理虚函数表应该如何处理"></a>23. 实现编译器处理虚函数表应该如何处理</h2><p>虚函数表的主要目的是提供一张表，表上记录子类父类的虚函数地址，通过虚函数表可以达到动态绑定的目的。</p>
<p>编译器首先在编译阶段完成虚函数表的建立，然后当给父类的指针初始化指向的是哪个子类，编译器按照绑定的子类去虚函数表中找对应子类的虚函数，并绑定，这样达到了动态绑定的目的，主要这个绑定是发生在运行的阶段。</p>
<h2 id="24-析构函数一般写成虚函数的原因"><a href="#24-析构函数一般写成虚函数的原因" class="headerlink" title="24. 析构函数一般写成虚函数的原因"></a>24. 析构函数一般写成虚函数的原因</h2><p>因为在继承中，我们最后要销毁对象的时候，会调用析构函数，这个时候我们希望析构的是子类的对象，那么我们需要调用子类的析构函数，但是这个时候指针又是父类的指针，所以这个时候我们也要对析构函数写成虚构函数，这样析构函数的虚属性也会被继承，那么无论我们什么时候析构，都能动态绑定到我们需要析构的对象上。</p>
<h2 id="25-构造函数为什么一般不定义为虚函数"><a href="#25-构造函数为什么一般不定义为虚函数" class="headerlink" title="25. 构造函数为什么一般不定义为虚函数"></a>25. 构造函数为什么一般不定义为虚函数</h2><p>三个原因：<br>1.虚函数的作用是什么？是实现部分或默认的功能，而且该功能可以被子类所修改。如果父类的构造函数设置成虚函数，那么子类的构造函数会直接覆盖掉父类的构造函数。而父类的构造函数就失去了一些初始化的功能。这与子类的构造需要先完成父类的构造的流程相违背了。而这个后果会相当严重。</p>
<p>2.虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则。</p>
<p>3.虚函数的调用是由父类指针进行完成的，而对象的构造则是由编译器完成的，由于在创建一个对象的过程中，涉及到资源的创建，类型的确定，而这些是无法在运行过程中确定的，需要在编译的过程中就确定下来。而多态是在运行过程中体现出来的，所以是不能够通过虚函数来创建构造函数的，与实例化的次序不同也有关系。</p>
<p>那么虚够函数为什么可以设计成虚函数呢？由于虚函数是释放对象的时候才执行的，所以一开始也就无法确定析够函数的。而去由于析构的过程中，是先析构子类对象，后析构父类对象。所以，需要通过虚函数来指引子类对象。所以，如果不设置成虚函数的话，析构函数是无法执行子类的析构函数的。</p>
<h2 id="26-构造函数或者析构函数中调用虚函数会怎样"><a href="#26-构造函数或者析构函数中调用虚函数会怎样" class="headerlink" title="26. 构造函数或者析构函数中调用虚函数会怎样"></a>26. 构造函数或者析构函数中调用虚函数会怎样</h2><p>为什么呢？这是由于构造函数或者析构函数中调用虚函数这个时候，子类或许出于一个未初始化的状态，因为c++中父类先构造然后是子类，那么父类中构造调用子类，都没有构造，调用子类的虚函数，显然是错误的。</p>
<h2 id="27-纯虚函数"><a href="#27-纯虚函数" class="headerlink" title="27. 纯虚函数"></a>27. 纯虚函数</h2><p>纯虚函数不需要定义，我们不能够为纯虚函数提供函数体，同样的，包含纯虚函数的基类是抽象基类，抽象基类是不能创建对象的，只能通过继承，继承子类中覆盖纯虚函数，执行自己的功能，子类是可以创建对象的。</p>
<h2 id="28-静态绑定和动态绑定的介绍"><a href="#28-静态绑定和动态绑定的介绍" class="headerlink" title="28. 静态绑定和动态绑定的介绍"></a>28. 静态绑定和动态绑定的介绍</h2><p>静态绑定：通过用户定义指针指向的类型来进行绑定，在编译的时候已经完成。</p>
<p>动态邦定：c++中虚函数的功能，通过虚函数表，在运行阶段进行绑定，即运行的时候才知道绑定的函数。</p>
<h2 id="29-引用是否能实现动态绑定，为什么引用可以实现"><a href="#29-引用是否能实现动态绑定，为什么引用可以实现" class="headerlink" title="29. 引用是否能实现动态绑定，为什么引用可以实现"></a>29. 引用是否能实现动态绑定，为什么引用可以实现</h2><p>可以实现，因为动态绑定是发生在程序运行阶段的，c++中动态绑定是通过对基类的引用或者指针调用虚函数时发生。<br>因为引用或者指针的对象是可以在编译的时候不确定的，如果是直接传对象的话，在程序编译的阶段就会完成，对于引用，其实就是地址，在编译的时候可以不绑定对象，在实际运行的时候，在通过虚函数绑定对象即可。</p>
<h2 id="30-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><a href="#30-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）" class="headerlink" title="30. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"></a>30. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h2><p>深拷贝就是拷贝内容，浅拷贝就是拷贝指针。<br>浅拷贝拷贝指针，也就是说同一个对象，拷贝了两个指针，指向了同一个对象，那么当销毁的时候，可能两个指针销毁，就会导致内存泄漏的问题。<br>深拷贝不存在这个问题，因为是首先申请和拷贝数据一样大的内存空间，把数据复制过去。这样拷贝多少次，就有多少个不同的内存空间，干扰不到对方。</p>
<h2 id="31-对象复用的了解，零拷贝的了解"><a href="#31-对象复用的了解，零拷贝的了解" class="headerlink" title="31. 对象复用的了解，零拷贝的了解"></a>31. 对象复用的了解，零拷贝的了解</h2><p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p>
<h2 id="32-介绍C-所有的构造函数"><a href="#32-介绍C-所有的构造函数" class="headerlink" title="32.  介绍C++所有的构造函数"></a>32.  介绍C++所有的构造函数</h2><p>默认构造函数、一般构造函数、拷贝构造函数<br>默认构造函数（无参数）：如果创建一个类你没有写任何构造函数,则系统会自动生成默认的构造函数，或者写了一个不带任何形参的构造函数。<br>一般构造函数：一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）。<br>拷贝构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中。参数（对象的引用）是不可变的（const类型）。此函数经常用在函数调用时用户定义类型的值传递及返回。</p>
<h2 id="33-什么情况下会调用拷贝构造函数（三种情况）"><a href="#33-什么情况下会调用拷贝构造函数（三种情况）" class="headerlink" title="33. 什么情况下会调用拷贝构造函数（三种情况）"></a>33. 什么情况下会调用拷贝构造函数（三种情况）</h2><p>（1）用类的一个对象去初始化另一个对象时<br>（2）当函数的形参是类的对象时（也就是值传递时），如果是<strong>引用传递则不会调用</strong><br>（3）当函数的返回值是类的对象或引用时</p>
<h2 id="34-结构体内存对齐方式和为什么要进行内存对齐？"><a href="#34-结构体内存对齐方式和为什么要进行内存对齐？" class="headerlink" title="34. 结构体内存对齐方式和为什么要进行内存对齐？"></a>34. 结构体内存对齐方式和为什么要进行内存对齐？</h2><p>1.前面的地址必须是后面的地址正数倍,不是就补齐<br>2.整个Struct的地址必须是最大字节的整数倍<br>为什么要？<br>空间换时间，加快cpu访问内存的效率，这是因为许多计算机系统对基本数据类型合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K（通常是2、4或8）的倍数。这种对齐限制简化了形成处理器和存储器系统之间接口的硬件设计</p>
<h2 id="35-内存泄露的定义，如何检测与避免？"><a href="#35-内存泄露的定义，如何检测与避免？" class="headerlink" title="35. 内存泄露的定义，如何检测与避免？"></a>35. 内存泄露的定义，如何检测与避免？</h2><p>内存泄漏指的是开辟的内存没有释放，或者是存在用户操作的错误，导致野指针，无法释放原来分配的内存。</p>
<p>工具监测：在vs里面支持CRT这个库函数，函数里面有内存监测工具，可以调用，在程序中判断内存时否有泄漏。</p>
<p>人为监测：观测所有new开辟内存空间的地方有没有free掉。</p>
<p>避免：在编程习惯上要注意使用尽量使用STL函数，使用vector而不是数组，使用智能指针而不是指针。</p>
<h2 id="36-手写实现智能指针类（34-37我没遇见过）"><a href="#36-手写实现智能指针类（34-37我没遇见过）" class="headerlink" title="36. 手写实现智能指针类（34-37我没遇见过）"></a>36. 手写实现智能指针类（34-37我没遇见过）</h2><h2 id="37-调试程序的方法"><a href="#37-调试程序的方法" class="headerlink" title="37. 调试程序的方法"></a>37. 调试程序的方法</h2><p>这个方式很多，裸机程序，主动调试，gdb调试，IDE断点调试等。</p>
<h2 id="38-遇到coredump要怎么调试"><a href="#38-遇到coredump要怎么调试" class="headerlink" title="38. 遇到coredump要怎么调试"></a>38. 遇到coredump要怎么调试</h2><p>内存泄漏的方法很多，可以用gdb打开core文件，确定出错的堆栈地点，从而判断程序出错的位置。</p>
<h2 id="39-内存检查工具的了解"><a href="#39-内存检查工具的了解" class="headerlink" title="39. 内存检查工具的了解"></a>39. 内存检查工具的了解</h2><p>在vs里面支持CRT这个库函数</p>
<h2 id="40-模板的用法与适用场景"><a href="#40-模板的用法与适用场景" class="headerlink" title="40. 模板的用法与适用场景"></a>40. 模板的用法与适用场景</h2><p>模板是C11里面添加的，使用与在不知道类型的情况下，编写一个泛型的程序，模板通过用一个指定的关键字来代替类型，进行泛型编程。</p>
<p>应用场景：应用场景很多，例如我们要编程一些和类型无关的代码时，STL里面的很多容器都是用到了模板，容器的功能都可以使用，但并没有确定容器里面一定要用指定的类型，可以是任何的类型。</p>
<h2 id="41-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><a href="#41-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？" class="headerlink" title="41. 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"></a>41. 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h2><p>成员初始化的概念，就是说类的成员使用在定义的时候就使用构造函数初始值列表初始化</p>
<p>使用成员初始化要快些，这里说的快些是比较的是赋值，如果指定义变量，没有列表初始化，那么这样变量旧会执行默认的初始化，然后在赋值，这样就多了一次赋值操作，带来的开销取决于数据成员的类型。</p>
<p>除了效率之外，有一些成员必须列表初始化，例如<strong>**const</strong>或者<strong>**</strong>引用**</p>
<h2 id="42-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><a href="#42-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）" class="headerlink" title="42. 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"></a>42. 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h2><p>例如：auto、decltype,nullptr,for(auto i:m),lambda表达式，智能指针等。</p>
<h2 id="43-C-的调用惯例（简单一点C-函数调用的压栈过程）"><a href="#43-C-的调用惯例（简单一点C-函数调用的压栈过程）" class="headerlink" title="43. C++的调用惯例（简单一点C++函数调用的压栈过程）"></a>43. C++的调用惯例（简单一点C++函数调用的压栈过程）</h2><p>对于程序，编译器会对其分配一段内存，在逻辑上可以分为代码段，数据段，堆，栈<br>代码段：保存程序文本，指令指针EIP就是指向代码段，可读可执行不可写<br>数据段：保存初始化的全局变量和静态变量，可读可写不可执行<br>BSS：未初始化的全局变量和静态变量<br>堆(Heap)：动态分配内存，向地址增大的方向增长，可读可写可执行<br>栈(Stack)：存放局部变量，函数参数，当前状态，函数调用信息等，向地址减小的方向增长，非常非常重要，可读可写可执行</p>
<p>程序开始，从main开始，首先将参数压入栈，然后压入函数返回地址，进行函数调用，通过跳转指定进入函数，将函数内部的变量去堆栈上开辟空间，执行函数功能，执行完成，取回函数返回地址，进行下一个函数。</p>
<h2 id="44-C-的四种强制转换"><a href="#44-C-的四种强制转换" class="headerlink" title="44.  C++的四种强制转换"></a>44.  C++的四种强制转换</h2><p>四种强制转换是static_cast、dynamic_cast、const_cast、reinterpret_cast。</p>
<p>static_cast：静态强制转换，类似传统c语言里面括号的强制转换<br>dynamic_cast：动态强制转换，主要应用于多态，父子类的类型转换，dynamic_cast和static_cast不同的是，它会检查类型转换是否正确，不能转换，则会返回null，所以不算是强制转换。<br>const_cast：取出const属性，比较简单，可以把const类型转换为非conse指针类型。<br>reinterpret_cast：一种非常随意的二进制转换，简单理解对一个二进制序列的重新解释。</p>
<h2 id="45-阅读C-语言代码输出（）"><a href="#45-阅读C-语言代码输出（）" class="headerlink" title="45.阅读C++语言代码输出（）"></a>45.阅读C++语言代码输出（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> *p=arr;</span><br><span class="line">    *(p++)+=<span class="number">89</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,*p,*(++p));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出 3 3<br>第4行： <em>p=arr[0]<br>第5行：arr[0]=90;p自加1，此时</em>p=arr[1];<br>第6行：先计算<em>(++p),</em>p=arr[2],在计算*p=arr[2].原因prinf从右到左编译，从左到右输出<br>试了一下，cout也是如此<br>从右向左压值，从左向右调用。<br>cout &lt;&lt; a &lt;&lt; b;<br>相当于cout.operator &lt;&lt;(a).operator &lt;&lt;(b);</p>
<h2 id="46-阅读c-代码输出（）"><a href="#46-阅读c-代码输出（）" class="headerlink" title="46. 阅读c++代码输出（）"></a>46. 阅读c++代码输出（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>: <span class="keyword">int</span> a,b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    base1 ( <span class="keyword">int</span> i ) : b(i+<span class="number">1</span>),a(b)&#123;&#125;</span><br><span class="line">    base1():b(<span class="number">0</span>),a(b)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_a</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_b</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> b;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">base1 <span class="title">obj1</span><span class="params">(<span class="number">11</span>)</span></span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;obj1.get_a()&lt;&lt;<span class="built_in">endl</span>&lt;&lt;obj1.get_b()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出： 随机数 12</p>
<p>初始化列表的执行顺序是变量的声明顺序</p>
<h2 id="47-64位电脑-运行c-结果输出（）"><a href="#47-64位电脑-运行c-结果输出（）" class="headerlink" title="47. 64位电脑 运行c++结果输出（）"></a>47. 64位电脑 运行c++结果输出（）</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> <span class="keyword">virtual</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> a[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">char</span> c[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">cc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">aa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">        <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">bb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(B)&lt;&lt;<span class="built_in">endl</span>&lt;&lt;<span class="keyword">sizeof</span>(C);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-下列选项中，不可能是快速排序第2趟排序结果的是-（）"><a href="#48-下列选项中，不可能是快速排序第2趟排序结果的是-（）" class="headerlink" title="48. 下列选项中，不可能是快速排序第2趟排序结果的是 （）"></a>48. 下列选项中，不可能是快速排序第2趟排序结果的是 （）</h2><p>4 14 10 12 8 6 18<br>4 6 10 8 12 14 18<br>6 4 10 8 14 12 18<br>6 4 10 8 14 12 18</p>
<p>快速排序的核心思想是基准数就位，每一趟至少有一个基准数就位，所以两趟下来至少就位两个基准数就位，C选项只有18就位，所以错误</p>
<h2 id="49-单例模式、工厂模式-描述一下实际应用场景"><a href="#49-单例模式、工厂模式-描述一下实际应用场景" class="headerlink" title="49. 单例模式、工厂模式  描述一下实际应用场景"></a>49. 单例模式、工厂模式  描述一下实际应用场景</h2><h2 id="50-聊天室使用UDP-为什么？如果产生丢包怎么办？"><a href="#50-聊天室使用UDP-为什么？如果产生丢包怎么办？" class="headerlink" title="50. 聊天室使用UDP? 为什么？如果产生丢包怎么办？"></a>50. 聊天室使用UDP? 为什么？如果产生丢包怎么办？</h2><h2 id="51-X定义如下，若存在X-a-a-x-0x11223344-则a-y-1-的值可能为（）"><a href="#51-X定义如下，若存在X-a-a-x-0x11223344-则a-y-1-的值可能为（）" class="headerlink" title="51. X定义如下，若存在X a; a.x=0x11223344;则a.y[1]的值可能为（）"></a>51. X定义如下，若存在X a; a.x=0x11223344;则a.y[1]的值可能为（）</h2><p>union X{<br>    int x;<br>    char y[4];<br>};</p>
<p>联合体采用的是共享同一内存地址，且对齐，，int型为4个字节，char为1个字节，且大小为4，则该联合体一共占用4个字节的空间。<br>而对于int型赋值之后，即4个字节的空间上已经有了内容。<br>大端：低字节在高地址，0x44,0x33，0x22，0x11<br>小端：高字节在高地址，0x11,0x22,0x33,0x44<br>答案： 22， 33</p>
<h2 id="52-引用可以用-const修饰，只是没有什么作用，在VS2013上编译只是报警告而已。至于大家认为的-const-int-amp-a-b-这种写法叫做指向const-int-变量的引用-const修饰的是目标值，并不是修饰的引用。"><a href="#52-引用可以用-const修饰，只是没有什么作用，在VS2013上编译只是报警告而已。至于大家认为的-const-int-amp-a-b-这种写法叫做指向const-int-变量的引用-const修饰的是目标值，并不是修饰的引用。" class="headerlink" title="52. 引用可以用 const修饰，只是没有什么作用，在VS2013上编译只是报警告而已。至于大家认为的 const int&amp; a = b; 这种写法叫做指向const int 变量的引用,const修饰的是目标值，并不是修饰的引用。"></a>52. 引用可以用 const修饰，只是没有什么作用，在VS2013上编译只是报警告而已。至于大家认为的 const int&amp; a = b; 这种写法叫做指向const int 变量的引用,const修饰的是目标值，并不是修饰的引用。</h2><p>指针可以有顶层const, <code>const int* const p = p1;</code> 但是 引用就没有顶层const了。</p>
<h2 id="53-友元本质上是普通函数，不在类范畴中，没有-this、成员的概念。友元类不具有传递性、继承性、双向性。"><a href="#53-友元本质上是普通函数，不在类范畴中，没有-this、成员的概念。友元类不具有传递性、继承性、双向性。" class="headerlink" title="53. 友元本质上是普通函数，不在类范畴中，没有 this、成员的概念。友元类不具有传递性、继承性、双向性。"></a>53. 友元本质上是普通函数，不在类范畴中，没有 this、成员的概念。友元类不具有传递性、继承性、双向性。</h2><h2 id="54-任何指针都可以转化为void-void-可以转化为任何指针"><a href="#54-任何指针都可以转化为void-void-可以转化为任何指针" class="headerlink" title="54. 任何指针都可以转化为void * ,   void *可以转化为任何指针"></a>54. 任何指针都可以转化为void * ,   void *可以转化为任何指针</h2><p>指向任意非常量对象的指针能转换成void* ;<br>指向任意对象的指针能转换成const void*</p>
<h1 id="55-6个苹果-每天至少吃一个-吃完为止，一共有多少种？"><a href="#55-6个苹果-每天至少吃一个-吃完为止，一共有多少种？" class="headerlink" title="55. 6个苹果,每天至少吃一个,吃完为止，一共有多少种？"></a>55. 6个苹果,每天至少吃一个,吃完为止，一共有多少种？</h1><p>答案是：32.<br>六个一样的苹果，排成一排，之间有5个空。想像按吃的天数用隔板把它们分成每天不同的数量。<br>6天，相当用5个插板插入5个空中，苹果分成了6份：C（5，5）=1<br>5天，相当用4个插板插5个空，苹果分成了5份：C（5，4）=5<br>（这也不难理解：有一天是2个苹果，可以第1、2、3、4、5中的某一天吃）<br>4天，C（5，3）=10<br>3天，C（5，2）=10<br>2天，C（5，1）=5<br>1天，C（5，0）=1<br>总的方法为：1+5+10+10+5+1=32种.</p>
<h1 id="56-int-s-10-int-表示的是什么？"><a href="#56-int-s-10-int-表示的是什么？" class="headerlink" title="56. int (*s[10])(int) 表示的是什么？"></a>56. int (*s[10])(int) 表示的是什么？</h1><p>答案： 函数指针数组，每个指针指向一个int func(int param)的函数。</p>
<p>链接：<a href="https://www.nowcoder.com/questionTerminal/32372cbd0f22496481a91d9bfcdbc511" target="_blank" rel="noopener">https://www.nowcoder.com/questionTerminal/32372cbd0f22496481a91d9bfcdbc511</a><br>来源：牛客网</p>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>1、首先<em>s[10]  是一个指针数组，s 是一个含有10个指针的数组，故可以这样来看这条声明语句：假设 p 等价于 s[10],声明语句变为 int (</em>p)(int);<br>2、观察 int (<em>p)(int), 从名字开始，p前面有一个 * ，因此 p 是指针，有侧是形参列表，表示p指向的是函数，在观察左侧，函数返回的是 int；<br>3、则 int (</em>p)(int) 解读为：函数指针，指向一个 int func(int param) 的函数；<br>4、故 int (*s[10])(int) :解读为：函数指针数组，每个指针指向一个 int func(int param)的函数。</p>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>一个简单的方法，把<em>读作 （</em>后面的内容）is a pointer points to （*前面的内容） 这里就可以读作 s［10］is a pointer points to int (int)，即指向函数的指针数组。</p>
<h1 id="57-memset-memcpy-strcpy"><a href="#57-memset-memcpy-strcpy" class="headerlink" title="57. memset memcpy strcpy"></a>57. memset memcpy strcpy</h1><h1 id="58-字符串连接函数strcat"><a href="#58-字符串连接函数strcat" class="headerlink" title="58. 字符串连接函数strcat"></a>58. 字符串连接函数strcat</h1><h1 id="59-二叉排序树的查找路径"><a href="#59-二叉排序树的查找路径" class="headerlink" title="59. 二叉排序树的查找路径"></a>59. 二叉排序树的查找路径</h1><p><img src="//zhhp1001.github.io/2019/07/31/面试总结/2.png" alt></p>
<p>解析： 前面的节点， 或者比后面的节点都大， 或者比后面的节点都小</p>
<p>二叉排序树， 又叫二叉查找树， 它或者是一棵空树</p>
<h1 id="判断有向图是否有环（回路）"><a href="#判断有向图是否有环（回路）" class="headerlink" title="判断有向图是否有环（回路）"></a>判断有向图是否有环（回路）</h1><p>判断是否有环方法：1.拓扑排序<br>                2.深度优先遍历<br>                3.广度优先遍历</p>

      
    </div>

    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div></div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/wechatpay.png" alt="zhhp 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="/images/alipay.png" alt="zhhp 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>zhhp</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://zhhp1001.github.io/2019/07/31/面试总结/" title="面试总结">http://zhhp1001.github.io/2019/07/31/面试总结/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/面试/" rel="tag"><i class="fa fa-tag"></i> 面试</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/07/12/判断是否为BST/" rel="next" title="判断是否为BST">
                <i class="fa fa-chevron-left"></i> 判断是否为BST
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/08/15/背包-排序-剑指/" rel="prev" title="背包-排序-剑指">
                背包-排序-剑指 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <a href="/">
                <img class="site-author-image" itemprop="image" src="/images/head.jpg" alt="zhhp">
              </a>
            
              <p class="site-author-name" itemprop="name">zhhp</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">44</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">7</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:1195825804@qq.com" title="E-Mail &rarr; mailto:1195825804@qq.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://weibo.com/lossboy孙一峰" title="Weibo &rarr; https://weibo.com/lossboy孙一峰" rel="noopener" target="_blank"><i class="fa fa-fw fa-weibo"></i>Weibo</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-语言基础"><span class="nav-number">1.</span> <span class="nav-text">C++语言基础</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-指针和引用的区别"><span class="nav-number">1.1.</span> <span class="nav-text">1. 指针和引用的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-堆和栈的区别"><span class="nav-number">1.2.</span> <span class="nav-text">2. 堆和栈的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-new和delete是如何实现的，new-与-malloc的异同处"><span class="nav-number">1.3.</span> <span class="nav-text">3. new和delete是如何实现的，new 与 malloc的异同处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#new和delete功能覆盖了malloc-free，但因C-程序常会用到C函数，而C函数只能使用malloc-free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。"><span class="nav-number">1.4.</span> <span class="nav-text">new和delete功能覆盖了malloc/free，但因C++程序常会用到C函数，而C函数只能使用malloc/free管理动态内存。此外，使用是malloc和free搭配使用，new和delete搭配使用，不能混乱使用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-C和C-的区别"><span class="nav-number">1.5.</span> <span class="nav-text">4. C和C++的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类型检查"><span class="nav-number">1.5.1.</span> <span class="nav-text">类型检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#面向对象"><span class="nav-number">1.5.2.</span> <span class="nav-text">面向对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泛型编程（template）"><span class="nav-number">1.5.3.</span> <span class="nav-text">泛型编程（template）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常处理"><span class="nav-number">1.5.4.</span> <span class="nav-text">异常处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数重载-amp-运算符重载"><span class="nav-number">1.5.5.</span> <span class="nav-text">函数重载 &amp; 运算符重载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#标准模板库（STL）"><span class="nav-number">1.5.6.</span> <span class="nav-text">标准模板库（STL）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-C-、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）"><span class="nav-number">1.6.</span> <span class="nav-text">5. C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Struct和class的区别"><span class="nav-number">1.7.</span> <span class="nav-text">6. Struct和class的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-define-和const的区别（编译阶段、安全性、内存占用等）"><span class="nav-number">1.8.</span> <span class="nav-text">7. define 和const的区别（编译阶段、安全性、内存占用等）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-在C-中const和static的用法（定义，用途）"><span class="nav-number">1.9.</span> <span class="nav-text">8. 在C++中const和static的用法（定义，用途）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-const和static在类中使用的注意事项（定义、初始化和使用）"><span class="nav-number">1.10.</span> <span class="nav-text">9. const和static在类中使用的注意事项（定义、初始化和使用）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-C-中的const类成员函数（用法和意义）"><span class="nav-number">1.11.</span> <span class="nav-text">10. C++中的const类成员函数（用法和意义）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-计算下面几个类的大小："><span class="nav-number">1.12.</span> <span class="nav-text">11.  计算下面几个类的大小：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-给一个代码，求输出结果"><span class="nav-number">1.13.</span> <span class="nav-text">12. 给一个代码，求输出结果</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-C-的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等"><span class="nav-number">1.14.</span> <span class="nav-text">13.  C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-STL源码中的hash表的实现"><span class="nav-number">1.15.</span> <span class="nav-text">14.  STL源码中的hash表的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-STL中unordered-map和map的区别"><span class="nav-number">1.16.</span> <span class="nav-text">15. STL中unordered_map和map的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-STL中vector的实现"><span class="nav-number">1.17.</span> <span class="nav-text">16. STL中vector的实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#17-vector使用的注意点及其原因，频繁对vector调用push-back-对性能的影响和原因。"><span class="nav-number">1.18.</span> <span class="nav-text">17. vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-C-中的重载和重写的区别"><span class="nav-number">1.19.</span> <span class="nav-text">18. C++中的重载和重写的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-C-内存管理（热门问题）"><span class="nav-number">1.20.</span> <span class="nav-text">19. C ++内存管理（热门问题）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-介绍面向对象的三大特性，并且举例说明每一个。"><span class="nav-number">1.21.</span> <span class="nav-text">20. 介绍面向对象的三大特性，并且举例说明每一个。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-多态的实现（和下个问题一起回答）"><span class="nav-number">1.22.</span> <span class="nav-text">21. 多态的实现（和下个问题一起回答）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-C-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）"><span class="nav-number">1.23.</span> <span class="nav-text">22. C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#23-实现编译器处理虚函数表应该如何处理"><span class="nav-number">1.24.</span> <span class="nav-text">23. 实现编译器处理虚函数表应该如何处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-析构函数一般写成虚函数的原因"><span class="nav-number">1.25.</span> <span class="nav-text">24. 析构函数一般写成虚函数的原因</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-构造函数为什么一般不定义为虚函数"><span class="nav-number">1.26.</span> <span class="nav-text">25. 构造函数为什么一般不定义为虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-构造函数或者析构函数中调用虚函数会怎样"><span class="nav-number">1.27.</span> <span class="nav-text">26. 构造函数或者析构函数中调用虚函数会怎样</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-纯虚函数"><span class="nav-number">1.28.</span> <span class="nav-text">27. 纯虚函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-静态绑定和动态绑定的介绍"><span class="nav-number">1.29.</span> <span class="nav-text">28. 静态绑定和动态绑定的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-引用是否能实现动态绑定，为什么引用可以实现"><span class="nav-number">1.30.</span> <span class="nav-text">29. 引用是否能实现动态绑定，为什么引用可以实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）"><span class="nav-number">1.31.</span> <span class="nav-text">30. 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-对象复用的了解，零拷贝的了解"><span class="nav-number">1.32.</span> <span class="nav-text">31. 对象复用的了解，零拷贝的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-介绍C-所有的构造函数"><span class="nav-number">1.33.</span> <span class="nav-text">32.  介绍C++所有的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-什么情况下会调用拷贝构造函数（三种情况）"><span class="nav-number">1.34.</span> <span class="nav-text">33. 什么情况下会调用拷贝构造函数（三种情况）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-结构体内存对齐方式和为什么要进行内存对齐？"><span class="nav-number">1.35.</span> <span class="nav-text">34. 结构体内存对齐方式和为什么要进行内存对齐？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-内存泄露的定义，如何检测与避免？"><span class="nav-number">1.36.</span> <span class="nav-text">35. 内存泄露的定义，如何检测与避免？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-手写实现智能指针类（34-37我没遇见过）"><span class="nav-number">1.37.</span> <span class="nav-text">36. 手写实现智能指针类（34-37我没遇见过）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-调试程序的方法"><span class="nav-number">1.38.</span> <span class="nav-text">37. 调试程序的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-遇到coredump要怎么调试"><span class="nav-number">1.39.</span> <span class="nav-text">38. 遇到coredump要怎么调试</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-内存检查工具的了解"><span class="nav-number">1.40.</span> <span class="nav-text">39. 内存检查工具的了解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-模板的用法与适用场景"><span class="nav-number">1.41.</span> <span class="nav-text">40. 模板的用法与适用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？"><span class="nav-number">1.42.</span> <span class="nav-text">41. 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）"><span class="nav-number">1.43.</span> <span class="nav-text">42. 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#43-C-的调用惯例（简单一点C-函数调用的压栈过程）"><span class="nav-number">1.44.</span> <span class="nav-text">43. C++的调用惯例（简单一点C++函数调用的压栈过程）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#44-C-的四种强制转换"><span class="nav-number">1.45.</span> <span class="nav-text">44.  C++的四种强制转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-阅读C-语言代码输出（）"><span class="nav-number">1.46.</span> <span class="nav-text">45.阅读C++语言代码输出（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-阅读c-代码输出（）"><span class="nav-number">1.47.</span> <span class="nav-text">46. 阅读c++代码输出（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-64位电脑-运行c-结果输出（）"><span class="nav-number">1.48.</span> <span class="nav-text">47. 64位电脑 运行c++结果输出（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-下列选项中，不可能是快速排序第2趟排序结果的是-（）"><span class="nav-number">1.49.</span> <span class="nav-text">48. 下列选项中，不可能是快速排序第2趟排序结果的是 （）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-单例模式、工厂模式-描述一下实际应用场景"><span class="nav-number">1.50.</span> <span class="nav-text">49. 单例模式、工厂模式  描述一下实际应用场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-聊天室使用UDP-为什么？如果产生丢包怎么办？"><span class="nav-number">1.51.</span> <span class="nav-text">50. 聊天室使用UDP? 为什么？如果产生丢包怎么办？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-X定义如下，若存在X-a-a-x-0x11223344-则a-y-1-的值可能为（）"><span class="nav-number">1.52.</span> <span class="nav-text">51. X定义如下，若存在X a; a.x=0x11223344;则a.y[1]的值可能为（）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-引用可以用-const修饰，只是没有什么作用，在VS2013上编译只是报警告而已。至于大家认为的-const-int-amp-a-b-这种写法叫做指向const-int-变量的引用-const修饰的是目标值，并不是修饰的引用。"><span class="nav-number">1.53.</span> <span class="nav-text">52. 引用可以用 const修饰，只是没有什么作用，在VS2013上编译只是报警告而已。至于大家认为的 const int&amp; a = b; 这种写法叫做指向const int 变量的引用,const修饰的是目标值，并不是修饰的引用。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-友元本质上是普通函数，不在类范畴中，没有-this、成员的概念。友元类不具有传递性、继承性、双向性。"><span class="nav-number">1.54.</span> <span class="nav-text">53. 友元本质上是普通函数，不在类范畴中，没有 this、成员的概念。友元类不具有传递性、继承性、双向性。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-任何指针都可以转化为void-void-可以转化为任何指针"><span class="nav-number">1.55.</span> <span class="nav-text">54. 任何指针都可以转化为void * ,   void *可以转化为任何指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#55-6个苹果-每天至少吃一个-吃完为止，一共有多少种？"><span class="nav-number">2.</span> <span class="nav-text">55. 6个苹果,每天至少吃一个,吃完为止，一共有多少种？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#56-int-s-10-int-表示的是什么？"><span class="nav-number">3.</span> <span class="nav-text">56. int (*s[10])(int) 表示的是什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#思路1"><span class="nav-number">3.1.</span> <span class="nav-text">思路1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#思路2"><span class="nav-number">3.2.</span> <span class="nav-text">思路2</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#57-memset-memcpy-strcpy"><span class="nav-number">4.</span> <span class="nav-text">57. memset memcpy strcpy</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#58-字符串连接函数strcat"><span class="nav-number">5.</span> <span class="nav-text">58. 字符串连接函数strcat</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#59-二叉排序树的查找路径"><span class="nav-number">6.</span> <span class="nav-text">59. 二叉排序树的查找路径</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#判断有向图是否有环（回路）"><span class="nav-number">7.</span> <span class="nav-text">判断有向图是否有环（回路）</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhhp</span>

  

  
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
    </span>
  
</div>









        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>












  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.2"></script>



  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  
  

<script src="//cdn1.lncld.net/static/js/3.11.1/av-min.js"></script>



<script src="//unpkg.com/valine/dist/Valine.min.js"></script>

<script>
  var GUEST = ['nick', 'mail', 'link'];
  var guest = 'nick,mail,link';
  guest = guest.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#comments',
    verify: false,
    notify: false,
    appId: '37hsvbqjjw8KTaqELMkHrQHn-gzGzoHsz',
    appKey: 'HsDWsgoAL6gfAczManvngfO2',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: guest,
    pageSize: '10' || 10,
    visitor: false,
    lang: '' || 'zh-cn'
  });
</script>




  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  
  
  <script>
    
    function addCount(Counter) {
      var $visitors = $('.leancloud_visitors');
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();

      Counter('get', '/classes/Counter', { where: JSON.stringify({ url }) })
        .done(function({ results }) {
          if (results.length > 0) {
            var counter = results[0];
            
            Counter('put', '/classes/Counter/' + counter.objectId, JSON.stringify({ time: { '__op': 'Increment', 'amount': 1 } }))
            
              .done(function() {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.time + 1);
              })
            
              .fail(function ({ responseJSON }) {
                console.log('Failed to save Visitor num, with error message: ' + responseJSON.error);
              })
          } else {
            
              Counter('post', '/classes/Counter', JSON.stringify({ title: title, url: url, time: 1 }))
                .done(function() {
                  var $element = $(document.getElementById(url));
                  $element.find('.leancloud-visitors-count').text(1);
                })
                .fail(function() {
                  console.log('Failed to create');
                });
            
          }
        })
        .fail(function ({ responseJSON }) {
          console.log('LeanCloud Counter Error: ' + responseJSON.code + ' ' + responseJSON.error);
        });
    }
    

    $(function() {
      $.get('https://app-router.leancloud.cn/2/route?appId=' + '37hsvbqjjw8KTaqELMkHrQHn-gzGzoHsz')
        .done(function({ api_server }) {
          var Counter = function(method, url, data) {
            return $.ajax({
              method: method,
              url: 'https://' + api_server + '/1.1' + url,
              headers: {
                'X-LC-Id': '37hsvbqjjw8KTaqELMkHrQHn-gzGzoHsz',
                'X-LC-Key': 'HsDWsgoAL6gfAczManvngfO2',
                'Content-Type': 'application/json',
              },
              data: data
            });
          };
          
            addCount(Counter);
          
        });
    });
  </script>



  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
